<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guitar Trainer Pro</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Application d'entra√Ænement pour guitare avec d√©tection audio en temps r√©el">
    <meta name="theme-color" content="#00d4aa">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Guitar Trainer">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #151a23;
            --bg-tertiary: #1f2937;
            --accent-primary: #00d4aa;
            --accent-secondary: #00a8ff;
            --accent-danger: #ff3366;
            --accent-warning: #ffaa00;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --border: #30363d;
            --success: #3fb950;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'DM Sans', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, #0d1117 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
        }

        header {
            text-align: center;
            margin-bottom: 1.5rem;
            position: relative;
        }

        h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.25rem;
            letter-spacing: -0.02em;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1rem;
            font-weight: 500;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 1.5rem;
            margin-bottom: 1rem;
            transition: grid-template-columns 0.3s ease;
        }
        
        .main-grid.settings-hidden {
            grid-template-columns: 1fr;
            justify-items: center;
        }
        
        .main-grid.settings-hidden .display-panel {
            max-width: 1200px;
            width: 100%;
        }

        .settings-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.25rem;
            border: 1px solid var(--border);
            height: fit-content;
            position: sticky;
            top: 1rem;
            transition: all 0.3s ease;
        }
        
        .settings-panel.hidden {
            display: none;
        }

        .section-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--accent-primary);
            margin-bottom: 0.75rem;
            font-weight: 600;
        }

        .mode-selector {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            margin-bottom: 1.25rem;
        }

        .difficulty-selector {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            margin-bottom: 1.25rem;
        }

        .mode-btn, .difficulty-btn {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'DM Sans', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            text-align: left;
        }

        .mode-btn:hover {
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .mode-btn.active, .difficulty-btn.active {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border-color: transparent;
            color: var(--bg-primary);
        }

        .setting-group {
            margin-bottom: 1rem;
        }

        .setting-label {
            display: block;
            color: var(--text-secondary);
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            padding: 0.4rem;
            border-radius: 6px;
            transition: background 0.2s;
            font-size: 0.85rem;
        }

        .checkbox-label:hover {
            background: var(--bg-tertiary);
        }

        .chord-types-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.3rem;
        }

        .chord-only-section {
            display: block;
        }

        .chord-only-section.hidden {
            display: none;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }

        input[type="number"] {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            -moz-appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .display-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 1.25rem;
            border: 1px solid var(--border);
            height: fit-content;
            display: flex;
            flex-direction: column;
            justify-content: center;
            position: relative;
            transition: all 0.3s ease;
        }

        .exercise-display {
            text-align: center;
        }

        .timer-display {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 2px solid var(--border);
            display: inline-block;
        }

        .timer-label {
            font-size: 0.65rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.25rem;
        }

        .timer-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .timer-value.warning {
            color: var(--accent-warning);
            animation: timerPulse 0.5s infinite;
        }

        .timer-value.danger {
            color: var(--accent-danger);
            animation: timerPulse 0.3s infinite;
        }

        @keyframes timerPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .current-note {
            font-family: 'JetBrains Mono', monospace;
            font-size: 3rem;
            font-weight: 700;
            margin: 0.75rem 0;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
        }

        .note-notation {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-bottom: 1rem;
        }

        .notation {
            text-align: center;
        }

        .notation-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.25rem;
        }

        .notation-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            color: var(--text-primary);
            font-weight: 600;
        }

        .chord-notes-display {
            margin-top: 1rem;
            padding: 0.75rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 2px solid var(--border);
        }

        .chord-display-wrapper {
            display: flex;
            gap: 2rem;
            align-items: center;
            justify-content: center;
        }

        .chord-notes-section {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .chord-notes-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.25rem;
            text-align: center;
        }

        .chord-notes-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            color: var(--accent-primary);
            font-weight: 600;
            text-align: center;
            line-height: 1.4;
        }

        .chord-diagram-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .diagram-header {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .chord-diagram-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            text-align: center;
        }

        .diagram-navigation {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .diagram-nav-btn {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            color: var(--accent-primary);
            width: 32px;
            height: 32px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .diagram-nav-btn:hover:not(:disabled) {
            background: var(--accent-primary);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
        }

        .diagram-nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .position-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            min-width: 40px;
            text-align: center;
        }

        .chord-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .diagram-fret-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .diagram-grid {
            position: relative;
            display: inline-block;
        }

        .diagram-string {
            display: flex;
            align-items: center;
            gap: 0;
        }

        .diagram-string-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            width: 30px;
            text-align: center;
            font-weight: 600;
        }

        .diagram-fret {
            width: 45px;
            height: 30px;
            border: 1px solid var(--border);
            border-left: none;
            border-top: none;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .diagram-fret:first-of-type {
            border-left: 3px solid var(--text-primary);
        }

        .diagram-string:first-child .diagram-fret {
            border-top: 1px solid var(--border);
        }

        .diagram-finger {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--accent-primary);
            color: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 700;
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.4);
        }

        .diagram-open {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid var(--success);
            background: transparent;
        }

        .diagram-muted {
            color: var(--accent-danger);
            font-size: 1.1rem;
            font-weight: 700;
        }

        .diagram-legend {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            gap: 2rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .fret-numbers {
            display: flex;
            margin-top: 0.5rem;
            padding-left: 30px;
        }

        .fret-number {
            width: 45px;
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .control-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .btn {
            padding: 0.6rem 1.25rem;
            border: none;
            border-radius: 10px;
            font-family: 'DM Sans', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-primary);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 212, 170, 0.3);
        }

        .btn-secondary {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            border-color: var(--accent-primary);
        }

        .audio-detector {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 2px solid var(--border);
        }

        .audio-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .status-indicator.active {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .detected-note {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-top: 0.35rem;
        }

        .detected-note.correct {
            color: var(--success);
            animation: correctFlash 0.6s ease-in-out;
            font-weight: 700;
        }

        .detected-note.incorrect {
            color: var(--accent-danger);
        }

        @keyframes correctFlash {
            0%, 100% { 
                transform: scale(1);
                text-shadow: none;
            }
            50% { 
                transform: scale(1.3);
                text-shadow: 0 0 30px var(--success), 0 0 60px var(--success);
            }
        }

        .frequency-display {
            text-align: center;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            margin-top: 0.25rem;
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .settings-panel {
                position: static;
            }

            h1 {
                font-size: 1.75rem;
            }

            .current-note {
                font-size: 3rem;
            }

            .chord-display-wrapper {
                flex-direction: column;
                align-items: center;
            }

            .chord-notes-section {
                text-align: center;
                min-height: auto;
            }

            .chord-notes-label,
            .chord-notes-value {
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Toggle settings button -->
        <button id="toggleSettingsBtn" style="position: fixed; top: 1rem; left: 1rem; z-index: 1000; padding: 0.75rem 1rem; background: var(--bg-secondary); border: 2px solid var(--accent-primary); border-radius: 10px; color: var(--accent-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem; font-weight: 600; cursor: pointer; transition: all 0.3s; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);"
        onmouseover="this.style.background='var(--accent-primary)'; this.style.color='var(--bg-primary)'"
        onmouseout="this.style.background='var(--bg-secondary)'; this.style.color='var(--accent-primary)'">
            ‚öôÔ∏è
        </button>
        
        <header>
            <h1>GUITAR TRAINER PRO</h1>
            <p class="subtitle">Entra√Ænement avanc√© avec d√©tection audio</p>
        </header>

        <div class="main-grid" id="mainGrid">
            <!-- Settings Panel -->
            <div class="settings-panel" id="settingsPanel">
                <!-- 1. Mode d'exercice -->
                <div class="section-title">Mode d'exercice</div>
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="single">
                        üìç Notes individuelles
                    </button>
                    <button class="mode-btn" data-mode="speed">
                        ‚ö° Mode rapidit√©
                    </button>
                    <button class="mode-btn" data-mode="chords">
                        üéº Accords
                    </button>
                    <button class="mode-btn" data-mode="debug">
                        üî¨ Debug FFT
                    </button>
                    <button class="mode-btn" data-mode="tuner">
                        üéµ Accordeur
                    </button>
                </div>

                <!-- 2. Niveau de difficult√© -->
                <div class="section-title">Niveau de difficult√©</div>
                <div class="difficulty-selector">
                    <button class="difficulty-btn" data-difficulty="beginner">
                        üå± D√©butant (5 notes)
                    </button>
                    <button class="difficulty-btn active" data-difficulty="intermediate">
                        üìö Interm√©diaire (7 notes)
                    </button>
                    <button class="difficulty-btn" data-difficulty="advanced">
                        üé∏ Avanc√© (12 notes)
                    </button>
                    <!-- Expert mode temporarily disabled -->
                    <!--
                    <button class="difficulty-btn" data-difficulty="expert">
                        üèÜ Expert (multi-cordes)
                    </button>
                    -->
                </div>

                <!-- 3. Mode rapidit√© (conditionnel) -->
                <div id="speedModeSettings" style="display: none;">
                    <div class="section-title">Mode rapidit√©</div>
                    <div class="setting-group">
                        <label class="setting-label">Dur√©e du d√©fi (secondes)</label>
                        <input type="number" id="speedModeDuration" min="30" max="300" step="30" value="60">
                    </div>
                </div>

                <!-- 3b. Mode accords (conditionnel) -->
                <div id="chordsModeSettings" style="display: none;">
                    <div class="section-title">Mode accords</div>
                    <div class="setting-group">
                        <label class="setting-label">Types d'accords</label>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <label class="checkbox-label" style="margin: 0;">
                                <input type="checkbox" id="chordTypeMajor" checked>
                                <span>Majeur</span>
                            </label>
                            <label class="checkbox-label" style="margin: 0;">
                                <input type="checkbox" id="chordTypeMinor" checked>
                                <span>Mineur</span>
                            </label>
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Niveau</label>
                        <select id="chordsLevel" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem;">
                            <option value="basic" selected>üå± Basiques (5 accords)</option>
                            <option value="complete">üìö Complet (12 tonalit√©s)</option>
                        </select>
                    </div>
                </div>

                <!-- 3c. Mode Debug FFT (conditionnel) -->
                <div id="debugModeSettings" style="display: none;">
                    <div class="section-title">Mode Debug FFT</div>
                    <div class="setting-group">
                        <label class="setting-label">Temps d'√©coute (ms)</label>
                        <input type="number" id="debugCaptureDelay" min="200" max="2000" step="100" value="600">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            D√©lai avant de figer le spectre apr√®s d√©tection du signal
                        </div>
                    </div>
                    <div class="setting-group">
                        <label class="setting-label">Dur√©e de capture FFT (ms)</label>
                        <select id="debugBufferDuration" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem;">
                            <option value="93">93 ms (4096 samples)</option>
                            <option value="186">186 ms (8192 samples)</option>
                            <option value="371">371 ms (16384 samples)</option>
                            <option value="743">743 ms (32768 samples)</option>
                            <option value="1486" selected>1486 ms (65536 samples)</option>
                        </select>
                        <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                            Dur√©e du signal captur√© pour l'analyse FFT<br>
                            <span style="color: var(--accent-warning);">Plus long = meilleure r√©solution fr√©quentielle</span>
                        </div>
                    </div>
                    <div style="margin-top: 0.5rem; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border);">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.25rem;">‚ÑπÔ∏è Mode d'emploi</div>
                        <div style="font-size: 0.7rem; color: var(--text-secondary); line-height: 1.4;">
                            1. Jouez une note/accord<br>
                            2. Le spectre se fige automatiquement<br>
                            3. Analysez les fr√©quences brutes<br>
                            4. Cliquez Reset pour recommencer
                        </div>
                    </div>
                </div>

                <!-- 4. Visualisation manche -->
                <div id="fretboardVisualizationSection">
                <div class="section-title">Visualisation manche</div>
                <div class="setting-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showFretboardCheckbox" checked>
                        <span>Afficher la position sur le manche</span>
                    </label>
                </div>
                <div class="setting-group" id="instrumentSelection" style="display: none;">
                    <label class="setting-label">Type d'instrument</label>
                    <select id="instrumentType" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem;">
                        <option value="guitar-6">Guitare 6 cordes</option>
                        <option value="guitar-7">Guitare 7 cordes</option>
                        <option value="bass-4">Basse 4 cordes</option>
                        <option value="bass-5">Basse 5 cordes</option>
                    </select>
                </div>
                <div class="setting-group" id="fretCountSelection" style="display: none;">
                    <label class="setting-label">Nombre de frettes</label>
                    <select id="fretCount" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem;">
                        <option value="12" selected>12 frettes</option>
                        <option value="15">15 frettes</option>
                        <option value="24">24 frettes</option>
                    </select>
                </div>
                </div>

                <!-- 5. D√©tection audio -->
                <div class="section-title">D√©tection audio</div>
                <div class="setting-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="enableAudio" checked>
                        <span>Activer le microphone</span>
                    </label>
                </div>
                <div class="setting-group">
                    <label class="setting-label">Temps de grattage (ms)</label>
                    <input type="number" id="strumDelay" min="200" max="1500" step="50" value="600">
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        D√©lai avant analyse de l'accord (200-1500ms)<br>
                        <span style="color: var(--accent-warning);">Augmentez si grattage rapide d√©tecte trop de notes</span>
                    </div>
                </div>
                <div class="setting-group">
                    <label class="setting-label">Sensibilit√© de d√©tection (dB)</label>
                    <input type="range" id="detectionSensitivity" min="-80" max="-40" step="5" value="-60">
                    <div style="display: flex; justify-content: space-between; font-size: 0.7rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        <span>Plus sensible</span>
                        <span id="sensitivityValue">-60 dB</span>
                        <span>Moins sensible</span>
                    </div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        Seuil minimum de d√©tection du signal
                    </div>
                </div>
                <div class="setting-group">
                    <label class="setting-label">Nombre max de notes d√©tect√©es</label>
                    <select id="maxNotesDetected" style="width: 100%; padding: 0.5rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem;">
                        <option value="0">Illimit√© (toutes les notes)</option>
                        <option value="3" selected>3 notes les plus fortes</option>
                        <option value="4">4 notes les plus fortes</option>
                        <option value="5">5 notes les plus fortes</option>
                        <option value="6">6 notes (toutes les cordes)</option>
                    </select>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 0.25rem;">
                        Limite le nombre de notes pour ignorer les cordes sympathiques<br>
                        <span style="color: var(--accent-warning);">Utile si grattage rapide d√©tecte trop de notes</span>
                    </div>
                </div>
                <div class="setting-group">
                    <label class="setting-label">D√©lai avant passage (secondes)</label>
                    <input type="number" id="advanceDelay" min="0.5" max="5" step="0.5" value="1">
                </div>
                
                <!-- 6. Lecture audio -->
                <div class="section-title">Lecture audio</div>
                <div class="setting-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="playSoundCheckbox">
                        <span>Jouer le son de la note</span>
                    </label>
                </div>
                
                <!-- Version display -->
                <div style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border); text-align: center;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary); font-family: 'JetBrains Mono', monospace;">
                        Guitar Trainer Pro <span id="appVersion">v1.0.0</span>
                    </div>
                </div>
            </div>

            <!-- Display Panel -->
            <div class="display-panel">
                <!-- Settings open overlay message -->
                <div id="settingsOverlay" style="display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; text-align: center; background: var(--bg-secondary); padding: 2rem; border-radius: 16px; border: 2px solid var(--accent-primary); box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);">
                    <div style="font-size: 1.2rem; color: var(--accent-primary); margin-bottom: 0.5rem;">‚öôÔ∏è Configuration en cours</div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">Fermez les options pour commencer l'entra√Ænement</div>
                </div>
                
                <div class="exercise-display">
                    <!-- Speed mode stats (hidden by default) -->
                    <div id="speedModeStats" style="display: none; margin-bottom: 1rem; text-align: center;">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem;">
                            Dur√©e du d√©fi : <span id="speedModeDurationDisplay" style="color: var(--accent-primary); font-weight: 600;">60</span> secondes
                            <span style="opacity: 0.6; margin-left: 0.5rem;">(‚ò∞ Options pour modifier)</span>
                        </div>
                        <div style="display: flex; justify-content: center; gap: 2rem; margin-bottom: 0.75rem;">
                            <div>
                                <div style="font-size: 0.7rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem;">Temps restant</div>
                                <div id="speedModeTimer" style="font-family: 'JetBrains Mono', monospace; font-size: 1.8rem; font-weight: 700; color: var(--accent-primary);">60</div>
                            </div>
                            <div>
                                <div style="font-size: 0.7rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.25rem;">Score</div>
                                <div id="speedModeScore" style="font-family: 'JetBrains Mono', monospace; font-size: 1.8rem; font-weight: 700; color: var(--success);">0</div>
                            </div>
                        </div>
                        <button id="speedModeStartBtn" class="btn btn-primary" style="margin: 0 auto 0.75rem auto; justify-content: center;">
                            ‚ñ∂ D√©marrer le d√©fi
                        </button>
                    </div>
                    
                    <div id="singleNoteDisplay">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 1.5rem; flex-wrap: wrap;">
                            <div class="current-note" id="currentNote">‚Äî</div>
                            <div id="detectedChord" style="display: none; color: var(--accent-danger); font-size: 2.5rem; font-weight: 700; font-family: 'DM Sans', sans-serif;">‚Äî</div>
                        </div>
                        
                        <div class="note-notation">
                            <div class="notation">
                                <div class="notation-label">Internationale</div>
                                <div class="notation-value" id="intlNotation">‚Äî</div>
                            </div>
                            <div class="notation">
                                <div class="notation-label">Fran√ßaise</div>
                                <div class="notation-value" id="frNotation">‚Äî</div>
                            </div>
                        </div>
                    </div>

                    <!-- Fretboard visualization -->
                    <div id="fretboardDisplay" style="display: none; margin-top: 1.5rem; width: 100%;">
                        <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.75rem; text-align: center;">Position sur le manche</div>
                        <div id="fretboardCanvas" style="background: var(--bg-tertiary); padding: 1rem; border-radius: 12px; border: 2px solid var(--border); overflow-x: auto; max-width: 100%;"></div>
                        
                        <!-- Spectrum Visualizer (only in chord mode) -->
                        <div id="spectrumDisplay" style="display: none; margin-top: 1rem;">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.75rem; text-align: center;">Spectre des fr√©quences</div>
                            <canvas id="spectrumCanvas" width="800" height="200" style="width: 100%; max-width: 800px; height: auto; background: var(--bg-tertiary); border-radius: 8px; border: 2px solid var(--border); display: block; margin: 0 auto;"></canvas>
                            <div style="margin-top: 0.5rem; text-align: center; font-size: 0.7rem; color: var(--text-secondary); font-style: italic;">
                                üü¢ Vert = Fr√©quences attendues | üîµ Cyan = Spectre complet
                            </div>
                        </div>
                    </div>

                    <!-- Debug FFT mode display (hidden by default) -->
                    <div id="debugModeDisplay" style="display: none;">
                        <div style="text-align: center; margin-bottom: 1rem;">
                            <div style="font-size: 1.2rem; color: var(--accent-primary); margin-bottom: 0.5rem;">üî¨ Analyse FFT Brute</div>
                            <div id="debugStatus" style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 0.75rem;">
                                üé§ En attente d'un signal...
                            </div>
                            <!-- Reset button in main interface -->
                            <button id="debugResetBtn" class="btn" style="background: var(--accent-danger); color: white; padding: 0.5rem 1.5rem; font-size: 0.9rem;">
                                üîÑ Reset et r√©initialiser l'√©coute
                            </button>
                        </div>
                        
                        <!-- Raw Waveform (Time Domain) -->
                        <div style="margin-top: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                                <div style="display: flex; gap: 1rem; align-items: center;">
                                    <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em;">Signal Temporel Brut</div>
                                    <label class="checkbox-label" style="margin: 0;">
                                        <input type="checkbox" id="useZoomedFFT">
                                        <span style="font-size: 0.7rem;">FFT sur zone visible</span>
                                    </label>
                                </div>
                                <div style="display: flex; gap: 1rem; align-items: center;">
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <span style="font-size: 0.7rem; color: var(--text-secondary);">Zoom X:</span>
                                        <button id="zoomOutBtn" class="btn" style="padding: 0.25rem 0.5rem; font-size: 0.7rem; min-width: 30px;">‚àí</button>
                                        <span id="zoomLevel" style="font-size: 0.7rem; color: var(--accent-primary); min-width: 50px; text-align: center;">1√ó</span>
                                        <button id="zoomInBtn" class="btn" style="padding: 0.25rem 0.5rem; font-size: 0.7rem; min-width: 30px;">+</button>
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <span style="font-size: 0.7rem; color: var(--text-secondary);">Zoom Y:</span>
                                        <button id="zoomYOutBtn" class="btn" style="padding: 0.25rem 0.5rem; font-size: 0.7rem; min-width: 30px;">‚àí</button>
                                        <span id="zoomYLevel" style="font-size: 0.7rem; color: var(--accent-success); min-width: 50px; text-align: center;">1√ó</span>
                                        <button id="zoomYInBtn" class="btn" style="padding: 0.25rem 0.5rem; font-size: 0.7rem; min-width: 30px;">+</button>
                                    </div>
                                    <button id="zoomResetBtn" class="btn" style="padding: 0.25rem 0.5rem; font-size: 0.7rem;">Reset</button>
                                </div>
                            </div>
                            <canvas id="debugWaveformCanvas" width="1200" height="200" style="width: 100%; max-width: 1200px; height: auto; background: var(--bg-tertiary); border-radius: 8px; border: 2px solid var(--accent-secondary); display: block; margin: 0 auto; cursor: move;"></canvas>
                            <div style="margin-top: 0.25rem; text-align: center; font-size: 0.65rem; color: var(--text-secondary);">
                                üí° Cliquez et glissez pour d√©placer | Molette pour zoomer | Shift+Molette pour zoom vertical
                            </div>
                        </div>
                        
                        <!-- Raw FFT Spectrum -->
                        <div style="margin-top: 1rem;">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 0.75rem; text-align: center;">Spectre FFT Brut (Sans traitement)</div>
                            <canvas id="debugSpectrumCanvas" width="1200" height="400" style="width: 100%; max-width: 1200px; height: auto; background: var(--bg-tertiary); border-radius: 8px; border: 2px solid var(--accent-primary); display: block; margin: 0 auto;"></canvas>
                        </div>
                        
                        <!-- FFT Stats -->
                        <div id="debugStats" style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border); display: none;">
                            <div style="font-size: 0.8rem; color: var(--accent-primary); margin-bottom: 0.5rem; font-weight: 600;">üìä Statistiques FFT</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 0.75rem; font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;">
                                <div>
                                    <span style="color: var(--text-secondary);">Pic max:</span>
                                    <span id="debugMaxPeak" style="color: var(--accent-primary); margin-left: 0.5rem;">‚Äî</span>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary);">Magnitude max:</span>
                                    <span id="debugMaxMagnitude" style="color: var(--accent-primary); margin-left: 0.5rem;">‚Äî</span>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary);">Nombre de pics:</span>
                                    <span id="debugPeakCount" style="color: var(--accent-primary); margin-left: 0.5rem;">‚Äî</span>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary);">R√©solution FFT:</span>
                                    <span id="debugResolution" style="color: var(--accent-primary); margin-left: 0.5rem;">‚Äî</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Peak List -->
                        <div id="debugPeakList" style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border); max-height: 300px; overflow-y: auto; display: none;">
                            <div style="font-size: 0.8rem; color: var(--accent-primary); margin-bottom: 0.5rem; font-weight: 600;">üéµ Pics d√©tect√©s (grave ‚Üí aigu)</div>
                            <div id="debugPeakListContent" style="font-family: 'JetBrains Mono', monospace; font-size: 0.7rem; line-height: 1.6; color: var(--text-secondary);"></div>
                        </div>
                    </div>

                    <!-- Tuner mode display (hidden by default) -->
                    <div id="tunerModeDisplay" style="display: none;">
                        <div style="text-align: center; margin-bottom: 1.5rem;">
                            <div style="font-size: 1.5rem; color: var(--accent-primary); margin-bottom: 0.5rem;">üéµ Accordeur</div>
                        </div>
                        
                        <!-- Tuner Type Selector -->
                        <div style="margin-bottom: 1.5rem;">
                            <div style="display: flex; gap: 0.5rem; justify-content: center;">
                                <button class="tuner-type-btn active" data-tuner-type="single" style="flex: 1; max-width: 200px; padding: 0.75rem; background: var(--bg-tertiary); border: 2px solid var(--accent-primary); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                    üé∏ Corde par corde
                                </button>
                                <button class="tuner-type-btn" data-tuner-type="global" style="flex: 1; max-width: 200px; padding: 0.75rem; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-secondary); font-family: 'DM Sans', sans-serif; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                                    üéº Accordage global
                                </button>
                            </div>
                        </div>
                        
                        <!-- Tuning Type Selector -->
                        <div style="margin-bottom: 1.5rem;">
                            <label style="display: block; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem; text-align: center;">Type d'accordage</label>
                            <select id="tuningTypeSelect" style="width: 100%; max-width: 300px; margin: 0 auto; display: block; padding: 0.75rem; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-family: 'DM Sans', sans-serif; font-size: 0.9rem;">
                                <option value="standard">Standard (E-A-D-G-B-E)</option>
                                <option value="drop-d">Drop D (D-A-D-G-B-E)</option>
                                <option value="drop-c">Drop C (C-G-C-F-A-D)</option>
                                <option value="open-g">Open G (D-G-D-G-B-D)</option>
                                <option value="open-d">Open D (D-A-D-F#-A-D)</option>
                                <option value="dadgad">DADGAD (D-A-D-G-A-D)</option>
                            </select>
                        </div>
                        
                        <!-- Single String Tuner (Corde par corde) -->
                        <div id="singleStringTuner">
                            <div style="text-align: center; margin-bottom: 0.75rem;">
                                <div style="font-size: 0.9rem; color: var(--text-secondary);">Jouez une corde √† vide</div>
                            </div>
                            
                            <!-- Current Note Display -->
                            <div style="text-align: center; margin-bottom: 2rem;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.1em; margin-bottom: 1rem;">Note d√©tect√©e</div>
                                <div id="tunerNoteName" style="font-size: 6rem; font-weight: 700; color: var(--accent-primary); line-height: 1; font-family: 'JetBrains Mono', monospace;">‚Äî</div>
                                <div id="tunerFrequency" style="font-size: 1.2rem; color: var(--text-secondary); margin-top: 0.5rem; font-family: 'JetBrains Mono', monospace;">‚Äî Hz</div>
                            </div>
                            
                            <!-- Tuning Meter -->
                            <div style="margin-bottom: 2rem;">
                                <div style="position: relative; height: 100px; background: var(--bg-tertiary); border-radius: 12px; overflow: hidden; border: 2px solid var(--border);">
                                    <!-- Center line -->
                                    <div style="position: absolute; left: 50%; top: 0; bottom: 0; width: 3px; background: var(--text-secondary); z-index: 1;"></div>
                                    
                                    <!-- Tuning zones -->
                                    <div style="position: absolute; left: 0; right: 50%; top: 0; bottom: 0; background: linear-gradient(to right, rgba(255, 100, 100, 0.2), rgba(255, 200, 100, 0.2));"></div>
                                    <div style="position: absolute; left: 50%; right: 0; top: 0; bottom: 0; background: linear-gradient(to left, rgba(255, 100, 100, 0.2), rgba(255, 200, 100, 0.2));"></div>
                                    <div style="position: absolute; left: 48%; right: 48%; top: 0; bottom: 0; background: rgba(0, 212, 170, 0.3); z-index: 0;"></div>
                                    
                                    <!-- Needle -->
                                    <div id="tunerNeedle" style="position: absolute; left: 50%; top: 10px; bottom: 10px; width: 4px; margin-left: -2px; background: var(--accent-primary); border-radius: 2px; transition: transform 0.15s ease-out; z-index: 2; box-shadow: 0 0 10px rgba(0, 212, 170, 0.5);"></div>
                                </div>
                                
                                <!-- Cents indicator -->
                                <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-secondary);">
                                    <span>‚àí50¬¢</span>
                                    <span id="tunerCents" style="color: var(--accent-primary); font-weight: 600; font-size: 0.9rem;">0¬¢</span>
                                    <span>+50¬¢</span>
                                </div>
                            </div>
                            
                            <!-- Tuning Status -->
                            <div id="tunerStatus" style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 2px solid var(--border);">
                                <div style="font-size: 1rem; color: var(--text-secondary);">üé∏ Jouez une corde...</div>
                            </div>
                        </div>
                        
                        <!-- Global Tuner (Accordage global) -->
                        <div id="globalTuner" style="display: none;">
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <div style="font-size: 0.9rem; color: var(--text-secondary);">Grattez toutes les cordes √† vide</div>
                            </div>
                            
                            <!-- Strings Status Grid -->
                            <div id="stringsStatusGrid" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.75rem; margin-bottom: 1.5rem;">
                                <!-- Will be populated by JavaScript -->
                            </div>
                            
                            <!-- Detected Notes Summary -->
                            <div id="detectedNotesSummary" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.5rem;">Notes d√©tect√©es</div>
                                <div id="detectedNotesContent" style="font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--text-primary);">
                                    Aucune note d√©tect√©e
                                </div>
                            </div>
                            
                            <!-- Strings to Adjust -->
                            <div id="stringsToAdjust" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 2px solid var(--border);">
                                <div style="font-size: 0.9rem; color: var(--accent-warning); margin-bottom: 0.75rem; font-weight: 600;">üîß Cordes √† ajuster</div>
                                <div id="stringsToAdjustContent" style="font-size: 0.85rem; line-height: 1.6;">
                                    Grattez toutes les cordes...
                                </div>
                            </div>
                            
                            <!-- Progress -->
                            <div style="text-align: center; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 2px solid var(--border);">
                                <div id="globalTunerProgress" style="font-size: 1.1rem; font-weight: 600;">
                                    <span style="color: var(--text-secondary);">Progression : </span>
                                    <span id="globalTunerProgressCount" style="color: var(--accent-primary);">0/6</span>
                                    <span style="color: var(--text-secondary);"> cordes OK</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Standard Guitar Tuning Reference -->
                        <div id="tuningReference" style="margin-top: 2rem; padding: 1rem; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0.75rem; text-align: center;">Accordage de r√©f√©rence</div>
                            <div id="tuningReferenceContent" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 0.5rem; font-family: 'JetBrains Mono', monospace; font-size: 0.75rem;">
                                <!-- Will be populated by JavaScript -->
                            </div>
                        </div>
                    </div>

                    <div class="chord-notes-display" id="chordNotesDisplay" style="display: none;">
                        <div class="chord-display-wrapper">
                            <div class="chord-notes-section">
                                <div class="chord-notes-label">Progression</div>
                                <div class="chord-notes-value" id="chordNotesValue">0/3 notes d√©tect√©es</div>
                            </div>
                        </div>
                    </div>

                    <div class="control-buttons" id="controlButtons">
                        <button class="btn btn-primary" id="nextBtn">
                            ‚ñ∂ Suivant
                        </button>
                    </div>

                    <div class="audio-detector" id="audioDetector" style="display: none;">
                        <div class="audio-status">
                            <div class="status-indicator" id="statusIndicator"></div>
                            <span id="statusText">Microphone d√©sactiv√©</span>
                        </div>
                        <div class="detected-note" id="detectedNote">‚Äî</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Application version
        const APP_VERSION = 'v4.1.0';
        
        // CRITICAL: Check domain FIRST and unregister any existing service worker on invalid domains
        const hostname = window.location.hostname;
        const isValidDomain = !hostname.includes('claudeusercontent') && 
                              !hostname.includes('localhost') && 
                              hostname !== '127.0.0.1';
        
        // Unregister any existing service workers on invalid domains
        if (!isValidDomain && 'serviceWorker' in navigator) {
            navigator.serviceWorker.getRegistrations().then(registrations => {
                registrations.forEach(registration => {
                    registration.unregister();
                    console.log('Service worker d√©sinstall√© (domaine invalide)');
                });
            }).catch(err => {
                console.log('Cleanup service worker ignor√©');
            });
            
            // Also clear caches
            if ('caches' in window) {
                caches.keys().then(names => {
                    names.forEach(name => {
                        caches.delete(name);
                    });
                });
            }
        }
        
        // Note mappings
        const noteToFrench = {
            'C': 'Do', 'C#': 'Do#', 'Db': 'R√©b', 'D': 'R√©', 'D#': 'R√©#', 
            'Eb': 'Mib', 'E': 'Mi', 'F': 'Fa', 'F#': 'Fa#', 'Gb': 'Solb',
            'G': 'Sol', 'G#': 'Sol#', 'Ab': 'Lab', 'A': 'La', 'A#': 'La#',
            'Bb': 'Sib', 'B': 'Si'
        };

        const allNotes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        
        // Chord types with their intervals (in semitones from root)
        const chordTypes = {
            'Majeur': { suffix: '', intervals: [0, 4, 7], french: 'Majeur' },
            'Mineur': { suffix: 'm', intervals: [0, 3, 7], french: 'Mineur' },
            '7': { suffix: '7', intervals: [0, 4, 7, 10], french: 'Septi√®me' },
            'Maj7': { suffix: 'Maj7', intervals: [0, 4, 7, 11], french: 'Septi√®me Majeure' },
            'm7': { suffix: 'm7', intervals: [0, 3, 7, 10], french: 'Mineur Septi√®me' },
            'dim': { suffix: 'dim', intervals: [0, 3, 6], french: 'Diminu√©' },
            'aug': { suffix: 'aug', intervals: [0, 4, 8], french: 'Augment√©' },
            'sus4': { suffix: 'sus4', intervals: [0, 5, 7], french: 'Suspendu 4' },
            'sus2': { suffix: 'sus2', intervals: [0, 2, 7], french: 'Suspendu 2' }
        };

        // Chord diagrams database (basic chords for training mode)
        // Format: frets = [-1 (X), 0 (open), 1-24 (fret number)]
        //         fingers = [0 (X/open), 1-4 (finger number)]
        const chordDiagrams = {
            // MAJOR CHORDS
            'C': { 
                name: 'Do Majeur', 
                notes: ['C', 'E', 'G'],
                frets: [-1, 3, 2, 0, 1, 0], // X-3-2-0-1-0
                fingers: [0, 3, 2, 0, 1, 0] // Index on B, Middle on D, Ring on A
            },
            'D': {
                name: 'R√© Majeur',
                notes: ['D', 'F#', 'A'],
                frets: [-1, -1, 0, 2, 3, 2],
                fingers: [0, 0, 0, 1, 3, 2]
            },
            'E': {
                name: 'Mi Majeur',
                notes: ['E', 'G#', 'B'],
                frets: [0, 2, 2, 1, 0, 0],
                fingers: [0, 2, 3, 1, 0, 0]
            },
            'F': {
                name: 'Fa Majeur',
                notes: ['F', 'A', 'C'],
                frets: [1, 3, 3, 2, 1, 1],
                fingers: [1, 3, 4, 2, 1, 1] // Barr√© index
            },
            'G': {
                name: 'Sol Majeur',
                notes: ['G', 'B', 'D'],
                frets: [3, 2, 0, 0, 0, 3],
                fingers: [2, 1, 0, 0, 0, 3]
            },
            'A': {
                name: 'La Majeur',
                notes: ['A', 'C#', 'E'],
                frets: [-1, 0, 2, 2, 2, 0],
                fingers: [0, 0, 1, 2, 3, 0]
            },
            'B': {
                name: 'Si Majeur',
                notes: ['B', 'D#', 'F#'],
                frets: [-1, 2, 4, 4, 4, 2],
                fingers: [0, 1, 2, 3, 4, 1] // Barr√©
            },
            
            // MINOR CHORDS
            'Am': {
                name: 'La Mineur',
                notes: ['A', 'C', 'E'],
                frets: [-1, 0, 2, 2, 1, 0],
                fingers: [0, 0, 2, 3, 1, 0]
            },
            'Dm': {
                name: 'R√© Mineur',
                notes: ['D', 'F', 'A'],
                frets: [-1, -1, 0, 2, 3, 1],
                fingers: [0, 0, 0, 2, 3, 1]
            },
            'Em': {
                name: 'Mi Mineur',
                notes: ['E', 'G', 'B'],
                frets: [0, 2, 2, 0, 0, 0],
                fingers: [0, 1, 2, 0, 0, 0]
            },
            'Fm': {
                name: 'Fa Mineur',
                notes: ['F', 'G#', 'C'],
                frets: [1, 3, 3, 1, 1, 1],
                fingers: [1, 3, 4, 1, 1, 1] // Barr√©
            },
            'Gm': {
                name: 'Sol Mineur',
                notes: ['G', 'A#', 'D'],
                frets: [3, 5, 5, 3, 3, 3],
                fingers: [1, 3, 4, 1, 1, 1] // Barr√©
            },
            'Bm': {
                name: 'Si Mineur',
                notes: ['B', 'D', 'F#'],
                frets: [-1, 2, 4, 4, 3, 2],
                fingers: [0, 1, 3, 4, 2, 1] // Barr√©
            },
            'Cm': {
                name: 'Do Mineur',
                notes: ['C', 'D#', 'G'],
                frets: [-1, 3, 5, 5, 4, 3],
                fingers: [0, 1, 3, 4, 2, 1] // Barr√©
            }
        };

        // Basic chords list (for beginner level)
        const basicChords = ['C', 'D', 'E', 'G', 'A', 'Am', 'Dm', 'Em'];

        // All chords for complete level
        const allChordsList = Object.keys(chordDiagrams);
        
        // Tuner configurations
        const tuningConfigs = {
            'standard': {
                name: 'Standard',
                strings: [
                    { note: 'E2', freq: 82.41, string: 6 },
                    { note: 'A2', freq: 110.00, string: 5 },
                    { note: 'D3', freq: 146.83, string: 4 },
                    { note: 'G3', freq: 196.00, string: 3 },
                    { note: 'B3', freq: 246.94, string: 2 },
                    { note: 'E4', freq: 329.63, string: 1 }
                ]
            },
            'drop-d': {
                name: 'Drop D',
                strings: [
                    { note: 'D2', freq: 73.42, string: 6 },
                    { note: 'A2', freq: 110.00, string: 5 },
                    { note: 'D3', freq: 146.83, string: 4 },
                    { note: 'G3', freq: 196.00, string: 3 },
                    { note: 'B3', freq: 246.94, string: 2 },
                    { note: 'E4', freq: 329.63, string: 1 }
                ]
            },
            'drop-c': {
                name: 'Drop C',
                strings: [
                    { note: 'C2', freq: 65.41, string: 6 },
                    { note: 'G2', freq: 98.00, string: 5 },
                    { note: 'C3', freq: 130.81, string: 4 },
                    { note: 'F3', freq: 174.61, string: 3 },
                    { note: 'A3', freq: 220.00, string: 2 },
                    { note: 'D4', freq: 293.66, string: 1 }
                ]
            },
            'open-g': {
                name: 'Open G',
                strings: [
                    { note: 'D2', freq: 73.42, string: 6 },
                    { note: 'G2', freq: 98.00, string: 5 },
                    { note: 'D3', freq: 146.83, string: 4 },
                    { note: 'G3', freq: 196.00, string: 3 },
                    { note: 'B3', freq: 246.94, string: 2 },
                    { note: 'D4', freq: 293.66, string: 1 }
                ]
            },
            'open-d': {
                name: 'Open D',
                strings: [
                    { note: 'D2', freq: 73.42, string: 6 },
                    { note: 'A2', freq: 110.00, string: 5 },
                    { note: 'D3', freq: 146.83, string: 4 },
                    { note: 'F#3', freq: 185.00, string: 3 },
                    { note: 'A3', freq: 220.00, string: 2 },
                    { note: 'D4', freq: 293.66, string: 1 }
                ]
            },
            'dadgad': {
                name: 'DADGAD',
                strings: [
                    { note: 'D2', freq: 73.42, string: 6 },
                    { note: 'A2', freq: 110.00, string: 5 },
                    { note: 'D3', freq: 146.83, string: 4 },
                    { note: 'G3', freq: 196.00, string: 3 },
                    { note: 'A3', freq: 220.00, string: 2 },
                    { note: 'D4', freq: 293.66, string: 1 }
                ]
            }
        };

        // State
        let currentMode = 'single';
        let currentDifficulty = 'intermediate';
        let currentExercise = null;
        let currentTunerType = 'single'; // 'single' or 'global'
        let currentTuning = 'standard';
        let lastGlobalTuningCheck = 0; // Timestamp for global tuner updates
        let lastSingleTunerDetection = 0; // Timestamp for last note detection
        let lastSingleTunerNote = null; // Last detected note info (persists for 3 seconds)
        const singleTunerPersistenceDuration = 5000; // 5 seconds persistence
        
        // Sliding average for tuner stability
        let tunerFrequencyHistory = []; // Array of {timestamp, frequency, magnitude}
        const tunerAverageWindow = 2000; // 2 seconds sliding window
        const tunerMinMagnitude = -55; // Minimum magnitude to consider (dB)
        
        // Note definitions for each difficulty level
        const difficultyLevels = {
            beginner: {
                name: 'D√©butant',
                notes: ['E', 'B', 'G', 'D', 'A'], // Open strings - unique notes only
                description: 'Cordes √† vide'
            },
            intermediate: {
                name: 'Interm√©diaire', 
                notes: ['C', 'D', 'E', 'F', 'G', 'A', 'B'], // Natural notes
                description: 'Notes naturelles'
            },
            advanced: {
                name: 'Avanc√©',
                notes: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'], // All chromatic
                description: 'Toutes les notes'
            },
            expert: {
                name: 'Expert',
                // Multi-string: same note on different strings
                notes: [
                    {note: 'E', strings: ['E2', 'E4']},
                    {note: 'F', strings: ['E2-1', 'E4-1']},
                    {note: 'G', strings: ['E2-3', 'D3', 'G3', 'E4-3']},
                    {note: 'A', strings: ['E2-5', 'A2', 'D3-7', 'G3-2', 'E4-5']},
                    {note: 'B', strings: ['A2-2', 'G3-4', 'B3', 'E4-7']},
                    {note: 'C', strings: ['A2-3', 'B3-1']},
                    {note: 'D', strings: ['A2-5', 'D3', 'B3-3', 'G3-7']},
                ],
                description: 'Multi-cordes'
            }
        };
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let isListening = false;
        let microphoneStream = null; // Store the stream to reuse it
        let microphonePermissionGranted = false; // Track if permission was already obtained
        let usedNotes = [];
        let availableNotes = [];
        let usedChords = [];
        let availableChords = [];
        let currentChordPositionIndex = 0;
        let currentChordName = null;
        let lastDetectedNote = null;
        let noteDetectionStartTime = 0;
        let stableNoteDuration = 100; // 100 milliseconds (responsive but stable)
        let hasAutoAdvanced = false;
        let chordDetectionStartTime = 0; // When first notes detected
        let chordTimeout = 2000; // After 2s without correct chord, reset and ask to retry
        let chordAnalysisScheduled = false; // Flag to prevent multiple scheduled analyses
        let globalBassNoteMissing = false; // Flag to persist bass missing state
        let globalMissingBassNote = null; // Which bass note is missing
        let frozenFFTData = null; // Store FFT data from analysis to freeze spectrum display
        let lastChordAnalysisTime = 0; // Track when we last analyzed to avoid spam
        
        // chordAnalysisDelay is now dynamic - read from strumDelayInput
        let waitingForRelease = false;
        let wakeLock = null;
        let audioContextSynth = null;
        let playNoteSound = true; // Toggle to enable/disable sound playback
        
        // Chord mode variables
        let chordNotesDetected = []; // Track which notes of the chord have been detected
        let wrongNotesPlayed = []; // Track incorrect notes played
        let wrongPositions = []; // Track exact positions (string, fret) of wrong notes
        let chordStringsPlayed = []; // Track which string indices have been played (to prevent counting same string multiple times)
        let chordModeLevel = 'basic'; // 'basic' or 'complete'
        let chordTypesEnabled = { major: true, minor: true };
        
        // Speed mode variables
        let speedModeActive = false;
        let speedModeTimerInterval = null;
        let speedModeTimeRemaining = 0;
        let speedModeCorrectCount = 0;
        let speedModeStartTime = 0;
        
        // Debug mode variables
        let debugModeActive = false;
        let debugCaptureStartTime = 0;
        let debugCaptureScheduled = false;
        let debugFrozenFFT = null;
        let waveformZoom = 1;
        let waveformZoomY = 1;
        let waveformOffset = 0;
        let waveformOffsetY = 0;
        let waveformDragging = false;
        let waveformDragStartX = 0;
        let waveformDragStartY = 0;
        let waveformDragStartOffset = 0;
        let waveformDragStartOffsetY = 0;
        
        // Fretboard state - track which strings are enabled
        let enabledStrings = {};
        
        // Instrument tunings (from low to high string)
        const instrumentTunings = {
            'guitar-6': {
                name: 'Guitare 6 cordes',
                strings: ['E2', 'A2', 'D3', 'G3', 'B3', 'E4'],
                notes: ['E', 'A', 'D', 'G', 'B', 'E'],
                notesFr: ['Mi', 'La', 'R√©', 'Sol', 'Si', 'Mi']
            },
            'guitar-7': {
                name: 'Guitare 7 cordes',
                strings: ['B1', 'E2', 'A2', 'D3', 'G3', 'B3', 'E4'],
                notes: ['B', 'E', 'A', 'D', 'G', 'B', 'E'],
                notesFr: ['Si', 'Mi', 'La', 'R√©', 'Sol', 'Si', 'Mi']
            },
            'bass-4': {
                name: 'Basse 4 cordes',
                strings: ['E1', 'A1', 'D2', 'G2'],
                notes: ['E', 'A', 'D', 'G'],
                notesFr: ['Mi', 'La', 'R√©', 'Sol']
            },
            'bass-5': {
                name: 'Basse 5 cordes',
                strings: ['B0', 'E1', 'A1', 'D2', 'G2'],
                notes: ['B', 'E', 'A', 'D', 'G'],
                notesFr: ['Si', 'Mi', 'La', 'R√©', 'Sol']
            }
        };

        // Elements
        const modeButtons = document.querySelectorAll('.mode-btn');
        const nextBtn = document.getElementById('nextBtn');
        const currentNoteEl = document.getElementById('currentNote');
        const detectedChordEl = document.getElementById('detectedChord');
        const intlNotationEl = document.getElementById('intlNotation');
        const frNotationEl = document.getElementById('frNotation');
        const detectedNoteEl = document.getElementById('detectedNote');
        const enableAudioCheckbox = document.getElementById('enableAudio');
        const audioDetector = document.getElementById('audioDetector');
        const statusIndicator = document.getElementById('statusIndicator');
        const statusText = document.getElementById('statusText');
        const advanceDelayInput = document.getElementById('advanceDelay');
        const strumDelayInput = document.getElementById('strumDelay');
        const detectionSensitivityInput = document.getElementById('detectionSensitivity');
        const maxNotesDetectedSelect = document.getElementById('maxNotesDetected');
        const sensitivityValueDisplay = document.getElementById('sensitivityValue');
        const playSoundCheckbox = document.getElementById('playSoundCheckbox');
        const speedModeDurationInput = document.getElementById('speedModeDuration');
        const speedModeStats = document.getElementById('speedModeStats');
        const speedModeTimer = document.getElementById('speedModeTimer');
        const speedModeScore = document.getElementById('speedModeScore');
        const speedModeStartBtn = document.getElementById('speedModeStartBtn');
        const speedModeDurationDisplay = document.getElementById('speedModeDurationDisplay');
        const showFretboardCheckbox = document.getElementById('showFretboardCheckbox');
        const fretboardVisualizationSection = document.getElementById('fretboardVisualizationSection');
        const instrumentSelection = document.getElementById('instrumentSelection');
        const fretCountSelection = document.getElementById('fretCountSelection');
        const instrumentType = document.getElementById('instrumentType');
        const fretCount = document.getElementById('fretCount');
        const fretboardDisplay = document.getElementById('fretboardDisplay');
        const fretboardCanvas = document.getElementById('fretboardCanvas');
        const toggleSettingsBtn = document.getElementById('toggleSettingsBtn');
        const settingsPanel = document.getElementById('settingsPanel');
        const mainGrid = document.getElementById('mainGrid');
        const settingsOverlay = document.getElementById('settingsOverlay');
        const displayPanel = document.querySelector('.display-panel');
        const speedModeSettings = document.getElementById('speedModeSettings');
        const chordsModeSettings = document.getElementById('chordsModeSettings');
        const debugModeSettings = document.getElementById('debugModeSettings');
        const debugModeDisplay = document.getElementById('debugModeDisplay');
        const tunerModeDisplay = document.getElementById('tunerModeDisplay');
        const tunerNoteName = document.getElementById('tunerNoteName');
        const tunerFrequency = document.getElementById('tunerFrequency');
        const tunerNeedle = document.getElementById('tunerNeedle');
        const tunerCents = document.getElementById('tunerCents');
        const tunerStatus = document.getElementById('tunerStatus');
        const tuningTypeSelect = document.getElementById('tuningTypeSelect');
        const singleStringTuner = document.getElementById('singleStringTuner');
        const globalTuner = document.getElementById('globalTuner');
        const stringsStatusGrid = document.getElementById('stringsStatusGrid');
        const detectedNotesContent = document.getElementById('detectedNotesContent');
        const stringsToAdjustContent = document.getElementById('stringsToAdjustContent');
        const globalTunerProgressCount = document.getElementById('globalTunerProgressCount');
        const tuningReferenceContent = document.getElementById('tuningReferenceContent');
        const debugWaveformCanvas = document.getElementById('debugWaveformCanvas');
        const debugSpectrumCanvas = document.getElementById('debugSpectrumCanvas');
        const debugStatus = document.getElementById('debugStatus');
        const debugStats = document.getElementById('debugStats');
        const debugPeakList = document.getElementById('debugPeakList');
        const debugPeakListContent = document.getElementById('debugPeakListContent');
        const debugMaxPeak = document.getElementById('debugMaxPeak');
        const debugMaxMagnitude = document.getElementById('debugMaxMagnitude');
        const debugPeakCount = document.getElementById('debugPeakCount');
        const debugResolution = document.getElementById('debugResolution');
        const debugCaptureDelayInput = document.getElementById('debugCaptureDelay');
        const debugBufferDurationSelect = document.getElementById('debugBufferDuration');
        const debugResetBtn = document.getElementById('debugResetBtn');
        const useZoomedFFT = document.getElementById('useZoomedFFT');
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomYInBtn = document.getElementById('zoomYInBtn');
        const zoomYOutBtn = document.getElementById('zoomYOutBtn');
        const zoomResetBtn = document.getElementById('zoomResetBtn');
        const zoomLevel = document.getElementById('zoomLevel');
        const zoomYLevel = document.getElementById('zoomYLevel');
        const chordTypeMajor = document.getElementById('chordTypeMajor');
        const chordTypeMinor = document.getElementById('chordTypeMinor');
        const chordsLevel = document.getElementById('chordsLevel');
        const singleNoteDisplay = document.getElementById('singleNoteDisplay');
        const chordNotesDisplay = document.getElementById('chordNotesDisplay');
        const chordNotesValue = document.getElementById('chordNotesValue');
        const chordDiagram = document.getElementById('chordDiagram');
        const controlButtons = document.getElementById('controlButtons');

        // Chord shapes database - format: [fret positions for strings 1-6 (e to E), finger numbers]
        // -1 = muted, 0 = open string
        // Each chord can have multiple positions (array of shapes)
        const chordShapes = {
            'C': [
                { frets: [0, 1, 0, 2, 3, -1], fingers: [0, 1, 0, 2, 3, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [5, 5, 5, 7, 8, 8], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 3' },
                { frets: [8, 8, 9, 10, 10, 8], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 8' }
            ],
            'Cm': [
                { frets: [3, 4, 5, 5, 3, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Barr√© en 3' },
                { frets: [8, 8, 8, 10, 11, 11], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 8' }
            ],
            'C7': [
                { frets: [0, 1, 3, 2, 3, -1], fingers: [0, 1, 4, 2, 3, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [5, 5, 5, 7, 6, 8], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Barr√© en 3' }
            ],
            'CMaj7': [
                { frets: [0, 0, 0, 2, 3, -1], fingers: [0, 0, 0, 2, 3, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Cm7': [
                { frets: [3, 1, 3, 1, 3, -1], fingers: [2, 1, 4, 1, 3, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Cdim': [
                { frets: [2, 4, 2, 4, 3, -1], fingers: [1, 3, 1, 4, 2, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Caug': [
                { frets: [0, 1, 1, 2, 3, -1], fingers: [0, 2, 1, 3, 4, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Csus4': [
                { frets: [1, 1, 0, 3, 3, -1], fingers: [2, 1, 0, 4, 3, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Csus2': [
                { frets: [3, 3, 0, 0, 3, -1], fingers: [4, 3, 0, 0, 2, 0], baseFret: 0, name: 'Position 1' }
            ],
            
            'D': [
                { frets: [2, 3, 2, 0, -1, -1], fingers: [2, 3, 1, 0, 0, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [7, 7, 7, 9, 10, 10], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 5' },
                { frets: [10, 10, 11, 12, 12, 10], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 10' }
            ],
            'Dm': [
                { frets: [1, 3, 2, 0, -1, -1], fingers: [1, 3, 2, 0, 0, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [5, 6, 7, 7, 5, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Barr√© en 5' },
                { frets: [10, 10, 10, 12, 13, 13], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 10' }
            ],
            'D7': [
                { frets: [2, 1, 2, 0, -1, -1], fingers: [3, 1, 2, 0, 0, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [7, 7, 7, 9, 8, 10], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Barr√© en 5' }
            ],
            'DMaj7': [
                { frets: [2, 2, 2, 0, -1, -1], fingers: [1, 1, 1, 0, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Dm7': [
                { frets: [1, 1, 2, 0, -1, -1], fingers: [1, 1, 2, 0, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Ddim': [
                { frets: [1, 0, 1, 0, -1, -1], fingers: [2, 0, 1, 0, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Daug': [
                { frets: [2, 3, 3, 0, -1, -1], fingers: [1, 3, 2, 0, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Dsus4': [
                { frets: [3, 3, 2, 0, -1, -1], fingers: [4, 3, 1, 0, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Dsus2': [
                { frets: [0, 3, 2, 0, -1, -1], fingers: [0, 2, 1, 0, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            
            'E': [
                { frets: [0, 0, 1, 2, 2, 0], fingers: [0, 0, 1, 3, 2, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [4, 4, 5, 6, 6, 4], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 4' },
                { frets: [7, 7, 9, 9, 9, 7], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 7' }
            ],
            'Em': [
                { frets: [0, 0, 0, 2, 2, 0], fingers: [0, 0, 0, 3, 2, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [7, 8, 9, 9, 7, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Barr√© en 7' },
                { frets: [12, 12, 12, 14, 15, 15], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 12' }
            ],
            'E7': [
                { frets: [0, 0, 1, 0, 2, 0], fingers: [0, 0, 1, 0, 2, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [7, 7, 7, 9, 8, 10], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Barr√© en 7' }
            ],
            'EMaj7': [
                { frets: [0, 0, 1, 1, 2, 0], fingers: [0, 0, 2, 1, 3, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Em7': [
                { frets: [0, 0, 0, 0, 2, 0], fingers: [0, 0, 0, 0, 2, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Edim': [
                { frets: [0, 2, 0, 2, 1, 0], fingers: [0, 4, 0, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Eaug': [
                { frets: [0, 1, 1, 2, 3, 0], fingers: [0, 2, 1, 3, 4, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Esus4': [
                { frets: [0, 0, 2, 2, 2, 0], fingers: [0, 0, 4, 3, 2, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Esus2': [
                { frets: [2, 5, 4, 2, 2, 0], fingers: [1, 3, 2, 1, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            
            'G': [
                { frets: [3, 0, 0, 0, 2, 3], fingers: [3, 0, 0, 0, 1, 2], baseFret: 0, name: 'Position ouverte' },
                { frets: [3, 2, 0, 0, 0, 3], fingers: [2, 1, 0, 0, 0, 3], baseFret: 0, name: 'Position ouverte alt.' },
                { frets: [10, 10, 10, 12, 13, 13], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 10' }
            ],
            'Gm': [
                { frets: [3, 3, 3, 5, 5, 3], fingers: [1, 1, 1, 4, 3, 1], baseFret: 0, name: 'Barr√© en 3' },
                { frets: [10, 11, 12, 12, 10, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Barr√© en 10' }
            ],
            'G7': [
                { frets: [1, 0, 0, 0, 2, 3], fingers: [1, 0, 0, 0, 2, 3], baseFret: 0, name: 'Position ouverte' },
                { frets: [3, 2, 3, 0, 0, 1], fingers: [3, 2, 4, 0, 0, 1], baseFret: 0, name: 'Position ouverte alt.' },
                { frets: [10, 10, 10, 12, 11, 13], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Barr√© en 10' }
            ],
            'GMaj7': [
                { frets: [2, 0, 0, 0, 2, 3], fingers: [2, 0, 0, 0, 1, 3], baseFret: 0, name: 'Position 1' }
            ],
            'Gm7': [
                { frets: [3, 3, 3, 3, 5, 3], fingers: [1, 1, 1, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Gdim': [
                { frets: [3, 5, 3, 5, 4, 3], fingers: [1, 3, 1, 4, 2, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Gaug': [
                { frets: [3, 0, 0, 1, 2, 3], fingers: [4, 0, 0, 1, 2, 3], baseFret: 0, name: 'Position 1' }
            ],
            'Gsus4': [
                { frets: [3, 1, 0, 0, 3, 3], fingers: [4, 1, 0, 0, 3, 2], baseFret: 0, name: 'Position 1' }
            ],
            'Gsus2': [
                { frets: [3, 3, 0, 0, 0, 3], fingers: [4, 3, 0, 0, 0, 2], baseFret: 0, name: 'Position 1' }
            ],
            
            'A': [
                { frets: [0, 2, 2, 2, 0, -1], fingers: [0, 3, 2, 1, 0, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [5, 5, 6, 7, 7, 5], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 5' },
                { frets: [9, 9, 11, 11, 11, 9], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 9' }
            ],
            'Am': [
                { frets: [0, 1, 2, 2, 0, -1], fingers: [0, 1, 3, 2, 0, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [5, 5, 5, 7, 8, 8], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 5' },
                { frets: [12, 12, 13, 14, 14, 12], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 12' }
            ],
            'A7': [
                { frets: [0, 2, 0, 2, 0, -1], fingers: [0, 3, 0, 2, 0, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [5, 5, 5, 7, 6, 8], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Barr√© en 5' }
            ],
            'AMaj7': [
                { frets: [0, 2, 1, 2, 0, -1], fingers: [0, 3, 1, 2, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Am7': [
                { frets: [0, 1, 0, 2, 0, -1], fingers: [0, 1, 0, 2, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Adim': [
                { frets: [2, 1, 2, 1, 0, -1], fingers: [4, 2, 3, 1, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Aaug': [
                { frets: [1, 2, 2, 3, 0, -1], fingers: [1, 3, 2, 4, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Asus4': [
                { frets: [0, 3, 2, 2, 0, -1], fingers: [0, 3, 2, 1, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Asus2': [
                { frets: [0, 0, 2, 2, 0, -1], fingers: [0, 0, 2, 1, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            
            // Barr√© chords for other notes
            'F': [
                { frets: [1, 1, 2, 3, 3, 1], fingers: [1, 1, 2, 4, 3, 1], baseFret: 0, name: 'Barr√© en 1' },
                { frets: [5, 5, 5, 7, 8, 8], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 5' },
                { frets: [8, 8, 10, 10, 10, 8], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 8' }
            ],
            'Fm': [
                { frets: [1, 1, 1, 3, 3, 1], fingers: [1, 1, 1, 4, 3, 1], baseFret: 0, name: 'Barr√© en 1' },
                { frets: [8, 9, 10, 10, 8, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Barr√© en 8' }
            ],
            'F7': [
                { frets: [1, 1, 2, 1, 3, 1], fingers: [1, 1, 2, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'FMaj7': [
                { frets: [1, 1, 2, 2, 3, 1], fingers: [1, 1, 2, 2, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Fm7': [
                { frets: [1, 1, 1, 1, 3, 1], fingers: [1, 1, 1, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Fdim': [
                { frets: [1, 3, 1, 3, 2, 1], fingers: [1, 3, 1, 4, 2, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Faug': [
                { frets: [1, 2, 2, 3, 0, 1], fingers: [1, 3, 2, 4, 0, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Fsus4': [
                { frets: [1, 1, 3, 3, 3, 1], fingers: [1, 1, 4, 4, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'Fsus2': [
                { frets: [1, 1, 0, 3, 3, 1], fingers: [1, 1, 0, 4, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            
            'B': [
                { frets: [2, 4, 4, 4, 2, -1], fingers: [1, 3, 3, 3, 1, 0], baseFret: 0, name: 'Barr√© en 2' },
                { frets: [7, 7, 8, 9, 9, 7], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 7' },
                { frets: [11, 11, 13, 13, 13, 11], fingers: [1, 1, 2, 3, 4, 1], baseFret: 0, name: 'Barr√© en 11' }
            ],
            'Bm': [
                { frets: [2, 3, 4, 4, 2, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Barr√© en 2' },
                { frets: [7, 7, 7, 9, 10, 10], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Barr√© en 7' }
            ],
            'B7': [
                { frets: [2, 0, 2, 1, 2, -1], fingers: [4, 0, 3, 1, 2, 0], baseFret: 0, name: 'Position ouverte' },
                { frets: [7, 7, 7, 9, 8, 10], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Barr√© en 7' }
            ],
            'BMaj7': [
                { frets: [2, 4, 3, 4, 2, -1], fingers: [1, 4, 2, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Bm7': [
                { frets: [2, 3, 2, 4, 2, -1], fingers: [1, 2, 1, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Bdim': [
                { frets: [4, 3, 4, 3, 2, -1], fingers: [3, 2, 4, 2, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Baug': [
                { frets: [3, 0, 0, 1, 2, -1], fingers: [4, 0, 0, 1, 2, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Bsus4': [
                { frets: [2, 5, 4, 4, 2, -1], fingers: [1, 4, 3, 2, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'Bsus2': [
                { frets: [2, 2, 4, 4, 2, -1], fingers: [1, 1, 4, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            
            // C# / Db chords (barr√© at fret 4 or 1)
            'C#': [
                { frets: [1, 1, 1, 3, 4, 4], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Position 1' }
            ],
            'C#m': [
                { frets: [1, 1, 2, 4, 4, 4], fingers: [1, 1, 2, 3, 3, 3], baseFret: 0, name: 'Position 1' }
            ],
            'C#7': [
                { frets: [1, 1, 1, 3, 2, 4], fingers: [1, 1, 1, 4, 2, 3], baseFret: 0, name: 'Position 1' }
            ],
            'C#Maj7': [
                { frets: [1, 1, 1, 3, 3, 3], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Position 1' }
            ],
            'C#m7': [
                { frets: [1, 1, 2, 4, 2, 4], fingers: [1, 1, 2, 4, 2, 3], baseFret: 0, name: 'Position 1' }
            ],
            'C#dim': [
                { frets: [0, 1, 2, 0, 2, 0], fingers: [0, 1, 3, 0, 4, 0], baseFret: 0, name: 'Position 1' }
            ],
            'C#aug': [
                { frets: [1, 2, 2, 3, 4, -1], fingers: [1, 2, 2, 3, 4, 0], baseFret: 0, name: 'Position 1' }
            ],
            'C#sus4': [
                { frets: [1, 1, 1, 4, 4, 4], fingers: [1, 1, 1, 2, 3, 4], baseFret: 0, name: 'Position 1' }
            ],
            'C#sus2': [
                { frets: [1, 1, 1, 1, 4, 4], fingers: [1, 1, 1, 1, 3, 4], baseFret: 0, name: 'Position 1' }
            ],
            
            // D# / Eb chords (barr√© at fret 6 or shapes based on D)
            'D#': [
                { frets: [3, 6, 5, 3, -1, -1], fingers: [1, 4, 3, 2, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#m': [
                { frets: [3, 6, 6, 3, -1, -1], fingers: [1, 3, 4, 2, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#7': [
                { frets: [3, 4, 3, 3, -1, -1], fingers: [2, 4, 3, 1, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#Maj7': [
                { frets: [3, 5, 4, 4, -1, -1], fingers: [1, 4, 2, 3, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#m7': [
                { frets: [3, 4, 3, 4, -1, -1], fingers: [2, 3, 1, 4, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#dim': [
                { frets: [3, 4, 2, 3, -1, -1], fingers: [2, 4, 1, 3, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#aug': [
                { frets: [3, 2, 1, 0, 0, 3], fingers: [4, 3, 2, 0, 0, 1], baseFret: 0, name: 'Position 1' }
            ],
            'D#sus4': [
                { frets: [3, 3, 4, 3, -1, -1], fingers: [1, 2, 4, 3, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            'D#sus2': [
                { frets: [3, 3, 3, 5, -1, -1], fingers: [1, 1, 1, 3, 0, 0], baseFret: 0, name: 'Position 1' }
            ],
            
            // F# / Gb chords (barr√© at fret 2)
            'F#': [
                { frets: [2, 2, 3, 4, 4, 2], fingers: [1, 1, 2, 4, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#m': [
                { frets: [2, 2, 2, 4, 4, 2], fingers: [1, 1, 1, 3, 4, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#7': [
                { frets: [2, 2, 3, 2, 4, 2], fingers: [1, 1, 3, 1, 4, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#Maj7': [
                { frets: [2, 2, 3, 3, 4, 2], fingers: [1, 1, 2, 2, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#m7': [
                { frets: [2, 2, 2, 2, 4, 2], fingers: [1, 1, 1, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#dim': [
                { frets: [2, 3, 4, 2, 4, 2], fingers: [1, 2, 4, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#aug': [
                { frets: [2, 1, 4, 3, 3, 2], fingers: [2, 1, 4, 3, 3, 2], baseFret: 0, name: 'Position 1' }
            ],
            'F#sus4': [
                { frets: [2, 2, 4, 4, 4, 2], fingers: [1, 1, 3, 3, 4, 1], baseFret: 0, name: 'Position 1' }
            ],
            'F#sus2': [
                { frets: [2, 2, 1, 4, 4, 2], fingers: [2, 2, 1, 3, 4, 2], baseFret: 0, name: 'Position 1' }
            ],
            
            // G# / Ab chords (barr√© at fret 4)
            'G#': [
                { frets: [4, 1, 1, 1, 3, 4], fingers: [3, 1, 1, 1, 2, 4], baseFret: 0, name: 'Position 1' }
            ],
            'G#m': [
                { frets: [4, 4, 4, 6, 6, 4], fingers: [1, 1, 1, 3, 4, 1], baseFret: 0, name: 'Position 1' }
            ],
            'G#7': [
                { frets: [4, 1, 1, 1, 2, 4], fingers: [3, 1, 1, 1, 2, 4], baseFret: 0, name: 'Position 1' }
            ],
            'G#Maj7': [
                { frets: [4, 1, 1, 1, 1, 4], fingers: [3, 1, 1, 1, 1, 4], baseFret: 0, name: 'Position 1' }
            ],
            'G#m7': [
                { frets: [4, 4, 4, 4, 6, 4], fingers: [1, 1, 1, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'G#dim': [
                { frets: [4, 5, 6, 4, 6, 4], fingers: [1, 2, 4, 1, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'G#aug': [
                { frets: [4, 3, 2, 1, 1, 0], fingers: [4, 3, 2, 1, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'G#sus4': [
                { frets: [4, 4, 1, 1, 2, 4], fingers: [3, 4, 1, 1, 2, 3], baseFret: 0, name: 'Position 1' }
            ],
            'G#sus2': [
                { frets: [4, 4, 1, 1, 4, 4], fingers: [2, 3, 1, 1, 4, 4], baseFret: 0, name: 'Position 1' }
            ],
            
            // A# / Bb chords (barr√© at fret 1)
            'A#': [
                { frets: [1, 3, 3, 3, 1, -1], fingers: [1, 3, 3, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#m': [
                { frets: [1, 2, 3, 3, 1, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#7': [
                { frets: [1, 3, 1, 3, 1, -1], fingers: [1, 3, 1, 4, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#Maj7': [
                { frets: [1, 3, 2, 3, 1, -1], fingers: [1, 4, 2, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#m7': [
                { frets: [1, 2, 1, 3, 1, -1], fingers: [1, 2, 1, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#dim': [
                { frets: [1, 2, 3, 2, 1, -1], fingers: [1, 2, 4, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#aug': [
                { frets: [1, 0, 3, 2, 2, 1], fingers: [1, 0, 4, 2, 3, 1], baseFret: 0, name: 'Position 1' }
            ],
            'A#sus4': [
                { frets: [1, 3, 3, 3, 1, -1], fingers: [1, 3, 3, 3, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
            'A#sus2': [
                { frets: [1, 1, 3, 3, 1, -1], fingers: [1, 1, 3, 4, 1, 0], baseFret: 0, name: 'Position 1' }
            ],
        };

        // Mode selection
        modeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                modeButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentMode = btn.dataset.mode;
                // Reset pools when changing mode
                availableNotes = [];
                availableChords = [];
                chordNotesDetected = [];
                
                // Show/hide mode-specific UI
                if (currentMode === 'speed') {
                    speedModeStats.style.display = 'block';
                    speedModeSettings.style.display = 'block';
                    chordsModeSettings.style.display = 'none';
                    debugModeSettings.style.display = 'none';
                    debugModeDisplay.style.display = 'none';
                    fretboardVisualizationSection.style.display = 'block'; // Show in speed mode
                    controlButtons.style.display = 'none';
                    singleNoteDisplay.style.display = 'block';
                    chordNotesDisplay.style.display = 'none';
                    stopSpeedMode();
                } else if (currentMode === 'chords') {
                    speedModeStats.style.display = 'none';
                    speedModeSettings.style.display = 'none';
                    chordsModeSettings.style.display = 'block';
                    debugModeSettings.style.display = 'none';
                    debugModeDisplay.style.display = 'none';
                    fretboardVisualizationSection.style.display = 'block'; // Show in chords mode
                    controlButtons.style.display = 'flex';
                    singleNoteDisplay.style.display = 'block'; // Show for chord name display
                    chordNotesDisplay.style.display = 'block'; // Show chord notes info
                    stopSpeedMode();
                } else if (currentMode === 'debug') {
                    console.log('üî¨ Switching to debug mode');
                    speedModeStats.style.display = 'none';
                    speedModeSettings.style.display = 'none';
                    chordsModeSettings.style.display = 'none';
                    debugModeSettings.style.display = 'block';
                    debugModeDisplay.style.display = 'block';
                    tunerModeDisplay.style.display = 'none';
                    fretboardVisualizationSection.style.display = 'none'; // Hide fretboard section in debug mode
                    fretboardDisplay.style.display = 'none'; // Hide fretboard display in debug mode
                    controlButtons.style.display = 'none';
                    singleNoteDisplay.style.display = 'none';
                    chordNotesDisplay.style.display = 'none';
                    stopSpeedMode();
                    resetDebugMode();
                } else if (currentMode === 'tuner') {
                    console.log('üéµ Switching to tuner mode');
                    speedModeStats.style.display = 'none';
                    speedModeSettings.style.display = 'none';
                    chordsModeSettings.style.display = 'none';
                    debugModeSettings.style.display = 'none';
                    debugModeDisplay.style.display = 'none';
                    tunerModeDisplay.style.display = 'block';
                    fretboardVisualizationSection.style.display = 'none'; // Hide in tuner mode (not needed)
                    controlButtons.style.display = 'none';
                    singleNoteDisplay.style.display = 'none';
                    chordNotesDisplay.style.display = 'none';
                    stopSpeedMode();
                    updateTuningReference();
                    if (currentTunerType === 'global') {
                        initGlobalTuner();
                    }
                } else {
                    speedModeStats.style.display = 'none';
                    speedModeSettings.style.display = 'none';
                    chordsModeSettings.style.display = 'none';
                    debugModeSettings.style.display = 'none';
                    debugModeDisplay.style.display = 'none';
                    tunerModeDisplay.style.display = 'none';
                    fretboardVisualizationSection.style.display = 'block'; // Show in single note mode
                    controlButtons.style.display = 'flex';
                    singleNoteDisplay.style.display = 'block';
                    chordNotesDisplay.style.display = 'none';
                    stopSpeedMode();
                }
                
                // Don't generate exercise in debug or tuner mode
                if (currentMode !== 'debug' && currentMode !== 'tuner') {
                    generateExercise();
                }
            });
        });

        // Difficulty selection
        const difficultyButtons = document.querySelectorAll('.difficulty-btn');
        difficultyButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                difficultyButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentDifficulty = btn.dataset.difficulty;
                // Reset pools when changing difficulty
                availableNotes = [];
                
                generateExercise();
            });
        });

        // Tuner type selection (Single vs Global)
        const tunerTypeButtons = document.querySelectorAll('.tuner-type-btn');
        tunerTypeButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                tunerTypeButtons.forEach(b => {
                    b.classList.remove('active');
                    b.style.background = 'var(--bg-secondary)';
                    b.style.borderColor = 'var(--border)';
                    b.style.color = 'var(--text-secondary)';
                });
                btn.classList.add('active');
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.borderColor = 'var(--accent-primary)';
                btn.style.color = 'var(--text-primary)';
                
                currentTunerType = btn.dataset.tunerType;
                
                if (currentTunerType === 'single') {
                    singleStringTuner.style.display = 'block';
                    globalTuner.style.display = 'none';
                } else {
                    singleStringTuner.style.display = 'none';
                    globalTuner.style.display = 'block';
                    initGlobalTuner();
                }
            });
        });
        
        // Tuning type selection
        if (tuningTypeSelect) {
            tuningTypeSelect.addEventListener('change', (e) => {
                currentTuning = e.target.value;
                updateTuningReference();
                if (currentTunerType === 'global') {
                    initGlobalTuner();
                }
            });
        }

        // Generate exercise
        function initializeNotesPool() {
            // Use notes based on current difficulty level
            const level = difficultyLevels[currentDifficulty];
            
            if (currentDifficulty === 'expert') {
                // Expert mode: return all note-string combinations
                const combinations = [];
                level.notes.forEach(noteObj => {
                    noteObj.strings.forEach(stringInfo => {
                        combinations.push({ 
                            note: noteObj.note, 
                            string: stringInfo 
                        });
                    });
                });
                return combinations;
            } else {
                // Other modes: simple note list
                return level.notes.map(note => ({ note }));
            }
        }

        function initializeChordsPool() {
            // Build list of chords based on level and selected types
            const level = chordsLevel.value; // 'basic' or 'complete'
            const includeMajor = chordTypeMajor.checked;
            const includeMinor = chordTypeMinor.checked;
            
            if (!includeMajor && !includeMinor) {
                return []; // No types selected
            }
            
            let chordsList = [];
            
            if (level === 'basic') {
                // Basic chords: C, D, E, G, A, Am, Dm, Em
                if (includeMajor) {
                    chordsList.push('C', 'D', 'E', 'G', 'A');
                }
                if (includeMinor) {
                    chordsList.push('Am', 'Dm', 'Em');
                }
            } else {
                // Complete: all chords in database
                if (includeMajor) {
                    chordsList.push('C', 'D', 'E', 'F', 'G', 'A', 'B');
                }
                if (includeMinor) {
                    chordsList.push('Am', 'Bm', 'Cm', 'Dm', 'Em', 'Fm', 'Gm');
                }
            }
            
            return chordsList;
        }

        function getRandomNote() {
            // Initialize pool if empty or first time
            if (availableNotes.length === 0) {
                availableNotes = initializeNotesPool();
                // Shuffle the array
                for (let i = availableNotes.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableNotes[i], availableNotes[j]] = [availableNotes[j], availableNotes[i]];
                }
            }
            
            // Pick and remove the first note from available pool
            const noteObj = availableNotes.shift();
            
            // Return object with note and string info (for expert mode)
            if (currentDifficulty === 'expert' && noteObj.string) {
                return { note: noteObj.note, string: noteObj.string };
            } else {
                return { note: noteObj.note };
            }
        }

        function getRandomChord() {
            // Initialize pool if empty or first time
            if (availableChords.length === 0) {
                availableChords = initializeChordsPool();
                // Shuffle the array
                for (let i = availableChords.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableChords[i], availableChords[j]] = [availableChords[j], availableChords[i]];
                }
            }
            
            // Pick and remove the first chord from available pool
            const chord = availableChords.shift();
            return chord;
        }

        function generateExercise() {
            const selectedStrings = ['E4', 'B3', 'G3', 'D3', 'A2', 'E2'];
            const minFret = 0;
            const maxFret = 12;
            
            // Reset chord detection timer and flag for new exercise
            chordDetectionStartTime = 0;
            chordAnalysisScheduled = false; // Allow new analysis for next chord
            frozenFFTData = null; // Clear frozen spectrum data
            
            // Clear previous detection results
            window.lastDetectedNotesWithFreq = null;
            wrongNotesPlayed = [];
            wrongPositions = [];
            chordNotesDetected = [];

            if (currentMode === 'single' || currentMode === 'speed') {
                // Both single and speed modes use single notes
                generateSingleNote(selectedStrings, minFret, maxFret);
            } else if (currentMode === 'chords') {
                generateChord();
            }

            // Don't update display immediately if audio is active and a note is being played
            if (isListening && lastDetectedNote !== null) {
                // Wait for note to be released before showing new exercise
                waitingForRelease = true;
                // Hide the current note while waiting
                currentNoteEl.textContent = '‚Äî';
                intlNotationEl.textContent = '‚Äî';
                frNotationEl.textContent = '‚Äî';
            } else {
                // No note being played, show immediately
                updateDisplay();
                waitingForRelease = false;
            }
            
            // Reset detected note display when changing exercise
            if (isListening) {
                if (waitingForRelease) {
                    // Show message to release the note
                    detectedNoteEl.textContent = 'Rel√¢chez la note pour passer √† la suivante';
                    detectedNoteEl.className = 'detected-note';
                } else {
                    detectedNoteEl.textContent = '‚Äî';
                    detectedNoteEl.className = 'detected-note';
                }
                lastDetectedNote = null;
                noteDetectionStartTime = 0;
                hasAutoAdvanced = false;
            }
        }






        function generateSingleNote(strings, minFret, maxFret) {
            const noteObj = getRandomNote();
            
            currentExercise = {
                type: 'single',
                notes: [noteObj],
                difficulty: currentDifficulty
            };
        }

        function generateChord() {
            const chordName = getRandomChord();
            
            if (!chordName || !chordDiagrams[chordName]) {
                console.error('Chord not found:', chordName);
                return;
            }
            
            const chordData = chordDiagrams[chordName];
            const instrument = instrumentTunings[instrumentType.value];
            const numStrings = instrument.strings.length;
            
            // Adapt chord to current instrument (truncate or extend)
            let adaptedFrets = [...chordData.frets];
            let adaptedFingers = [...chordData.fingers];
            
            if (numStrings > adaptedFrets.length) {
                // Add extra low strings (muted by default)
                const extraStrings = numStrings - adaptedFrets.length;
                for (let i = 0; i < extraStrings; i++) {
                    adaptedFrets.push(-1); // Mute extra strings
                    adaptedFingers.push(0);
                }
            } else if (numStrings < adaptedFrets.length) {
                // Remove high strings to fit instrument
                adaptedFrets = adaptedFrets.slice(0, numStrings);
                adaptedFingers = adaptedFingers.slice(0, numStrings);
            }
            
            // Count how many strings should be played (not muted = not -1)
            const stringsToPlay = adaptedFrets.filter(f => f !== -1).length;
            
            // Calculate expected frequencies for each string
            const expectedFrequencies = [];
            for (let s = 0; s < adaptedFrets.length; s++) {
                if (adaptedFrets[s] !== -1) { // Not muted
                    const openNote = instrument.notes[s];
                    const openNoteIndex = allNotes.indexOf(openNote);
                    const stringNoteIndex = (openNoteIndex + adaptedFrets[s]) % 12;
                    const stringNote = allNotes[stringNoteIndex];
                    
                    // Calculate exact frequency for this string
                    // Find which octave we're in
                    const openString = instrument.strings[s]; // e.g., "E2", "A2"
                    const octave = parseInt(openString.match(/\d+/)[0]);
                    const semitonesFromC0 = (octave * 12) + openNoteIndex + adaptedFrets[s];
                    const frequency = 16.35 * Math.pow(2, semitonesFromC0 / 12); // C0 = 16.35 Hz
                    
                    expectedFrequencies.push({
                        string: s,
                        note: stringNote,
                        frequency: frequency,
                        fret: adaptedFrets[s]
                    });
                }
            }
            
            currentExercise = {
                type: 'chord',
                chord: {
                    name: chordName,
                    displayName: chordData.name,
                    notes: chordData.notes,
                    frets: adaptedFrets,
                    fingers: adaptedFingers,
                    stringsToPlay: stringsToPlay, // Total strings that must be played
                    expectedFrequencies: expectedFrequencies // Frequencies for each string
                }
            };
            
            // Reset detection tracking
            chordNotesDetected = [];
            chordStringsPlayed = [];
        }

        function updateDisplay() {
            if (!currentExercise) return;

            if (currentExercise.type === 'single') {
                const noteObj = currentExercise.notes[0];
                const note = noteObj.note;
                
                // Display note name
                currentNoteEl.textContent = note;
                intlNotationEl.textContent = note;
                frNotationEl.textContent = noteToFrench[note];
                
                // For expert mode, show string info
                if (currentExercise.difficulty === 'expert' && noteObj.string) {
                    const stringDisplay = noteObj.string.replace(/([A-G]\d+)-?(\d*)/, (match, string, fret) => {
                        if (fret) {
                            return `Corde ${string} - Frette ${fret}`;
                        } else {
                            return `Corde ${string} √† vide`;
                        }
                    });
                    frNotationEl.textContent = noteToFrench[note] + ` (${stringDisplay})`;
                }
                
                // Draw fretboard if enabled
                drawFretboard(note);
                
                // Hide spectrum in single note mode
                const spectrumDisplay = document.getElementById('spectrumDisplay');
                if (spectrumDisplay) spectrumDisplay.style.display = 'none';
                
                // Play the note sound
                playNote(note);
            } else if (currentExercise.type === 'chord') {
                // Display chord name in main display (like single notes)
                const chord = currentExercise.chord;
                currentNoteEl.textContent = chord.name;
                
                // Display chord notes in notation sections
                intlNotationEl.textContent = chord.notes.join(' - ');
                frNotationEl.textContent = chord.notes.map(n => noteToFrench[n]).join(' - ');
                
                // Show progress in the chord notes area
                const progressText = `${chordNotesDetected.length}/${chord.stringsToPlay} cordes jou√©es`;
                const notesList = chordNotesDetected.length > 0 ? ` (${[...new Set(chordNotesDetected)].join(', ')})` : '';
                chordNotesValue.textContent = progressText + notesList;
                
                // Show spectrum in chord mode
                const spectrumDisplay = document.getElementById('spectrumDisplay');
                if (spectrumDisplay) spectrumDisplay.style.display = 'block';
                
                // Draw chord diagram on fretboard if enabled
                drawChordFretboard(chord);
            }
        }

        function drawSpectrum(expectedFrequencies, fftData) {
            const canvas = document.getElementById('spectrumCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);
            
            // Use pre-computed FFT data if provided, otherwise compute it
            let dataArray, bufferLength, nyquist;
            if (fftData) {
                ({ dataArray, bufferLength, nyquist } = fftData);
            } else {
                // Fallback: compute FFT if not provided
                const data = getFFTData();
                dataArray = data.dataArray;
                bufferLength = data.bufferLength;
                nyquist = data.nyquist;
            }
            
            // Draw frequency spectrum
            const minFreq = 50;  // 50 Hz
            const maxFreq = 600; // 600 Hz (better detail for guitar fundamentals)
            const freqRange = maxFreq - minFreq;
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = (i / 10) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw spectrum bars
            ctx.fillStyle = 'rgba(100, 200, 255, 0.6)'; // Cyan
            const barWidth = width / bufferLength;
            
            for (let i = 0; i < bufferLength; i++) {
                const freq = (i * nyquist) / bufferLength;
                
                if (freq >= minFreq && freq <= maxFreq) {
                    const x = ((freq - minFreq) / freqRange) * width;
                    const magnitude = dataArray[i];
                    
                    // Draw all spectrum data (no noise floor filter)
                    const normalizedHeight = Math.max(0, (magnitude + 100) / 100); // -100dB to 0dB normalized
                    const barHeight = normalizedHeight * height;
                    
                    ctx.fillRect(x, height - barHeight, barWidth * 2, barHeight);
                }
            }
            
            // Draw expected frequencies as vertical lines
            if (expectedFrequencies && expectedFrequencies.length > 0) {
                expectedFrequencies.forEach(expected => {
                    // Draw fundamental and harmonics
                    const harmonicsToShow = [
                        { freq: expected.frequency, label: expected.note, note: expected.note, style: 'solid' },
                        { freq: expected.frequency * 2, label: `${expected.note}√ó2`, note: expected.note, style: 'dashed' },
                        { freq: expected.frequency / 2, label: `${expected.note}√∑2`, note: expected.note, style: 'dotted' }
                    ];
                    
                    harmonicsToShow.forEach(harmonic => {
                        if (harmonic.freq >= minFreq && harmonic.freq <= maxFreq) {
                            const x = ((harmonic.freq - minFreq) / freqRange) * width;
                            
                            // Check if this frequency is ACTUALLY detected at the right octave
                            let isDetected = false;
                            
                            if (window.lastDetectedNotesWithFreq && harmonic.note) {
                                // Check if note is detected within ¬±10% of expected frequency (not just by name)
                                isDetected = window.lastDetectedNotesWithFreq.some(detected => {
                                    if (detected.note !== harmonic.note) return false;
                                    const freqRatio = detected.frequency / harmonic.freq;
                                    return freqRatio >= 0.9 && freqRatio <= 1.1;
                                });
                            }
                            
                            // Fallback: also check raw magnitude at this frequency
                            let maxMag = -100;
                            const binIndex = Math.round((harmonic.freq * bufferLength) / nyquist);
                            for (let offset = -2; offset <= 2; offset++) {
                                const checkBin = binIndex + offset;
                                if (checkBin >= 0 && checkBin < bufferLength) {
                                    maxMag = Math.max(maxMag, dataArray[checkBin]);
                                }
                            }
                            
                            // Draw vertical line
                            if (harmonic.style === 'solid') {
                                // Fundamental - thick line
                                ctx.strokeStyle = isDetected ? 'rgba(0, 255, 100, 0.9)' : 'rgba(255, 100, 100, 0.6)';
                                ctx.lineWidth = 3;
                            } else if (harmonic.style === 'dashed') {
                                // Harmonic - dashed line
                                ctx.strokeStyle = isDetected ? 'rgba(0, 255, 100, 0.5)' : 'rgba(255, 100, 100, 0.3)';
                                ctx.lineWidth = 2;
                                ctx.setLineDash([5, 5]);
                            } else {
                                // Sub-harmonic - dotted line
                                ctx.strokeStyle = isDetected ? 'rgba(0, 255, 100, 0.4)' : 'rgba(255, 100, 100, 0.2)';
                                ctx.lineWidth = 1;
                                ctx.setLineDash([2, 3]);
                            }
                            
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, height);
                            ctx.stroke();
                            ctx.setLineDash([]); // Reset dash
                            
                            // Draw label only for fundamental
                            if (harmonic.style === 'solid') {
                                ctx.fillStyle = isDetected ? '#00ff64' : '#ff6464';
                                ctx.font = 'bold 12px monospace';
                                ctx.textAlign = 'center';
                                ctx.fillText(`${expected.note}`, x, 15);
                                ctx.font = '10px monospace';
                                ctx.fillText(`${Math.round(expected.frequency)}Hz`, x, 28);
                                ctx.fillText(`${maxMag.toFixed(0)}dB`, x, height - 5);
                            }
                        }
                    });
                });
            }
            
            // Draw ALL detected notes (even if not in expected chord)
            if (window.lastDetectedNotesWithFreq && window.lastDetectedNotesWithFreq.length > 0) {
                window.lastDetectedNotesWithFreq.forEach(detected => {
                    if (detected.frequency >= minFreq && detected.frequency <= maxFreq) {
                        const x = ((detected.frequency - minFreq) / freqRange) * width;
                        
                        // Check if this frequency is close to an expected frequency
                        let isCloseToExpected = false;
                        if (expectedFrequencies) {
                            isCloseToExpected = expectedFrequencies.some(expected => {
                                return Math.abs(detected.frequency - expected.frequency) < 15; // Within 15 Hz
                            });
                        }
                        
                        // Only draw if NOT close to an expected frequency (to avoid duplicates)
                        if (!isCloseToExpected) {
                            // Draw cyan vertical line for detected note (not in expected)
                            ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                            ctx.lineWidth = 2;
                            ctx.setLineDash([3, 3]);
                            ctx.beginPath();
                            ctx.moveTo(x, 0);
                            ctx.lineTo(x, height);
                            ctx.stroke();
                            ctx.setLineDash([]);
                            
                            // Draw label at TOP (different from expected notes)
                            ctx.fillStyle = '#00ffff';
                            ctx.font = 'bold 11px monospace';
                            ctx.textAlign = 'center';
                            ctx.fillText(`${detected.note}`, x, 75);
                            ctx.font = '9px monospace';
                            ctx.fillText(`${Math.round(detected.frequency)}Hz`, x, 86);
                            
                            // Add "PARASITE" indicator
                            ctx.font = '8px monospace';
                            ctx.fillStyle = 'rgba(0, 255, 255, 0.6)';
                            ctx.fillText('‚ö†', x, 65);
                        }
                    }
                });
            }
            
            // Draw threshold lines
            const thresholdY = height * (1 - ((-60 + 100) / 100)); // -60 dB threshold
            ctx.strokeStyle = 'rgba(255, 200, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(0, thresholdY);
            ctx.lineTo(width, thresholdY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Label threshold
            ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('Seuil: -60dB', width - 5, thresholdY - 3);
            
            // Draw frequency axis labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '10px monospace';
            ctx.textAlign = 'left';
            for (let freq = 100; freq <= maxFreq; freq += 100) {
                const x = ((freq - minFreq) / freqRange) * width;
                ctx.fillText(`${freq}Hz`, x, height - 5);
            }
        }

        function drawChordFretboard(chord) {
            // Only display if checkbox is enabled (same as drawFretboard)
            if (!showFretboardCheckbox.checked) {
                fretboardDisplay.style.display = 'none';
                return;
            }
            
            fretboardDisplay.style.display = 'block';
            
            // Use same styling as drawFretboard
            const instrument = instrumentTunings[instrumentType.value];
            const numStrings = instrument.strings.length;
            
            // Get chord frets and fingers
            const frets = chord.frets;
            const fingers = chord.fingers;
            
            // Helper function to get the note at a given string and fret
            const getNoteAtPosition = (stringIndex, fretNum) => {
                const openNote = instrument.notes[stringIndex];
                const openNoteIndex = allNotes.indexOf(openNote);
                const noteIndex = (openNoteIndex + fretNum) % 12;
                return allNotes[noteIndex];
            };
            
            // Helper function to get frequency at a given string and fret
            const getFrequencyAtPosition = (stringIndex, fretNum) => {
                const openNote = instrument.notes[stringIndex];
                const openNoteIndex = allNotes.indexOf(openNote);
                const noteIndex = (openNoteIndex + fretNum) % 12;
                const noteName = allNotes[noteIndex];
                
                // Calculate octave based on string and fret
                const stringBaseOctaves = [2, 2, 3, 3, 3, 4]; // Standard tuning octaves (E2, A2, D3, G3, B3, E4)
                let octave = stringBaseOctaves[stringIndex];
                
                // Adjust octave based on fret
                const semitones = fretNum;
                octave += Math.floor((openNoteIndex + semitones) / 12);
                
                // Get base frequency for this note + octave
                const noteFrequencies = {
                    'C': [16.35, 32.70, 65.41, 130.81, 261.63, 523.25, 1046.50],
                    'C#': [17.32, 34.65, 69.30, 138.59, 277.18, 554.37, 1108.73],
                    'D': [18.35, 36.71, 73.42, 146.83, 293.66, 587.33, 1174.66],
                    'D#': [19.45, 38.89, 77.78, 155.56, 311.13, 622.25, 1244.51],
                    'E': [20.60, 41.20, 82.41, 164.81, 329.63, 659.25, 1318.51],
                    'F': [21.83, 43.65, 87.31, 174.61, 349.23, 698.46, 1396.91],
                    'F#': [23.12, 46.25, 92.50, 185.00, 369.99, 739.99, 1479.98],
                    'G': [24.50, 49.00, 98.00, 196.00, 392.00, 783.99, 1567.98],
                    'G#': [25.96, 51.91, 103.83, 207.65, 415.30, 830.61, 1661.22],
                    'A': [27.50, 55.00, 110.00, 220.00, 440.00, 880.00, 1760.00],
                    'A#': [29.14, 58.27, 116.54, 233.08, 466.16, 932.33, 1864.66],
                    'B': [30.87, 61.74, 123.47, 246.94, 493.88, 987.77, 1975.53]
                };
                
                return noteFrequencies[noteName] ? noteFrequencies[noteName][octave] : null;
            };
            
            // Map detected frequencies to likely fretboard positions
            const detectedPositions = new Set();
            
            console.log(`üéØ Mapping ${window.lastDetectedNotesWithFreq?.length || 0} detected frequencies to fretboard...`);
            
            if (window.lastDetectedNotesWithFreq && window.lastDetectedNotesWithFreq.length > 0) {
                window.lastDetectedNotesWithFreq.forEach(detected => {
                    console.log(`  üìç Trying to map: ${detected.note} @ ${detected.frequency.toFixed(1)}Hz`);
                    
                    // For each detected frequency, find all possible positions on fretboard
                    let bestMatch = null;
                    let bestDiff = Infinity;
                    let allMatches = []; // Track all potential matches for debugging
                    
                    for (let s = 0; s < numStrings; s++) {
                        const expectedFret = frets[s];
                        if (expectedFret === -1) continue; // Skip muted strings
                        
                        // Check positions around the expected fret (¬±2 frets)
                        for (let f = Math.max(0, expectedFret - 2); f <= Math.min(24, expectedFret + 2); f++) {
                            const posFreq = getFrequencyAtPosition(s, f);
                            if (!posFreq) continue;
                            
                            const diff = Math.abs(posFreq - detected.frequency);
                            const percentDiff = diff / detected.frequency;
                            
                            // If frequency matches within 2% (allows slight tuning variance)
                            if (percentDiff < 0.02) {
                                allMatches.push({ string: s, fret: f, freq: posFreq, diff: diff });
                                
                                if (diff < bestDiff) {
                                    bestDiff = diff;
                                    bestMatch = { string: s, fret: f };
                                }
                            }
                        }
                    }
                    
                    if (allMatches.length > 1) {
                        console.log(`    ‚ö†Ô∏è Multiple positions match ${detected.note} @ ${detected.frequency.toFixed(1)}Hz:`);
                        allMatches.forEach(m => {
                            const stringName = instrument.strings[numStrings - 1 - m.string];
                            console.log(`      - String ${m.string+1} (${stringName}) Fret ${m.fret} = ${m.freq.toFixed(1)}Hz (diff: ${m.diff.toFixed(2)}Hz) ${m === bestMatch ? '‚Üê CHOSEN' : ''}`);
                        });
                    }
                    
                    if (bestMatch) {
                        detectedPositions.add(`${bestMatch.string}-${bestMatch.fret}`);
                        const stringName = instrument.strings[numStrings - 1 - bestMatch.string]; // Reverse index
                        console.log(`    ‚úÖ Mapped to: String ${bestMatch.string+1} (${stringName}) Fret ${bestMatch.fret}`);
                    } else {
                        console.log(`    ‚ùå No match found on fretboard`);
                    }
                });
            }
            
            console.log(`üé∏ Final detected positions: ${Array.from(detectedPositions).join(', ')}`);

            
            // Calculate the range needed for this chord
            const hasOpenStrings = frets.some(f => f === 0); // Check for open strings
            const playedFrets = frets.filter(f => f > 0); // Exclude muted (-1) and open (0)
            const minFret = playedFrets.length > 0 ? Math.min(...playedFrets) : 0;
            const maxFret = playedFrets.length > 0 ? Math.max(...playedFrets) : 3;
            
            // Determine start and end frets to display (show 5-6 frets total)
            let startFret = 0;
            let endFret = 5;
            
            if (hasOpenStrings) {
                // If there are open strings, always start from fret 0
                startFret = 0;
                endFret = Math.max(5, maxFret + 1);
            } else if (minFret > 0) {
                // For barre chords without open strings, show from minFret-1
                startFret = Math.max(0, minFret - 1);
                endFret = Math.min(24, Math.max(startFret + 5, maxFret + 1));
            }
            
            const numFrets = endFret - startFret;
            
            // Fixed cell width for chord display (always 50px for clarity)
            const cellWidth = 50;
            const minWidth = (numFrets + 1) * cellWidth + 60; // +60 for string names
            
            
            // Build HTML for fretboard (same structure as drawFretboard)
            let html = `<div style="display: inline-block; min-width: ${minWidth}px; width: max-content;">`;
            
            // Fret numbers header
            html += '<div style="display: flex; align-items: center; margin-bottom: 0.25rem;">';
            html += '<div style="width: 50px;"></div>'; // Spacing for string names
            
            for (let fret = startFret; fret <= endFret; fret++) {
                html += `<div style="width: ${cellWidth}px; text-align: center; font-size: 0.7rem; color: var(--text-secondary); font-family: 'JetBrains Mono', monospace;">${fret}</div>`;
            }
            html += '</div>';
            
            // Draw strings (from high to low for visual clarity)
            for (let s = numStrings - 1; s >= 0; s--) {
                html += '<div style="display: flex; align-items: center; margin-bottom: 0.5rem;">';
                
                // String name - French notation
                const stringNoteFr = instrument.notesFr[s];
                const stringNum = instrument.strings[s].match(/\d+/)[0]; // Extract octave number
                
                // Check if string is muted for this chord
                const isMuted = frets[s] === -1;
                const stringColor = isMuted ? 'var(--accent-danger)' : 'var(--accent-primary)';
                
                html += `<div style="width: 50px; text-align: right; padding-right: 0.5rem; font-size: 0.8rem; color: ${stringColor}; font-family: 'JetBrains Mono', monospace; user-select: none;">${stringNoteFr}${stringNum}</div>`;
                
                // Frets
                for (let f = startFret; f <= endFret; f++) {
                    // Check if this is a chord position
                    const isChordPosition = frets[s] === f;
                    const fingerNum = isChordPosition ? fingers[s] : 0;
                    
                    // Calculate the note at this position
                    const noteAtPosition = getNoteAtPosition(s, f);
                    
                    // Check if the NOTE at this position has been detected (FFT-based)
                    let isDetected = false;
                    let isWrongNote = false;
                    
                    if (isChordPosition) {
                        // Check if this EXACT position (string + fret) was physically played
                        const posKey = `${s}-${f}`;
                        isDetected = detectedPositions.has(posKey);
                    }
                    
                    // Check if this EXACT position (string + fret) has a diagnosed error
                    if (!isChordPosition && wrongPositions.length > 0) {
                        isWrongNote = wrongPositions.some(pos => pos.stringIndex === s && pos.fret === f);
                    }
                    
                    // Color logic
                    let positionColor, bgColor, glowColor, size;
                    
                    if (isWrongNote) {
                        // Wrong note - show in red
                        positionColor = 'var(--accent-danger)';
                        bgColor = 'var(--accent-danger)';
                        glowColor = 'var(--accent-danger)';
                        size = '20px';
                    } else if (isChordPosition) {
                        // Chord position - green if detected, cyan if not
                        positionColor = isDetected ? 'var(--success)' : 'var(--accent-primary)';
                        bgColor = positionColor;
                        glowColor = isDetected ? 'var(--success)' : 'var(--accent-primary)';
                        size = '24px';
                    } else {
                        // Empty position
                        bgColor = f === startFret ? 'var(--bg-primary)' : 'transparent';
                        size = '10px';
                    }
                    
                    const borderColor = f === startFret ? 'var(--border)' : 'var(--text-secondary)';
                    
                    html += `<div style="width: ${cellWidth}px; height: 30px; display: flex; align-items: center; justify-content: center; border-left: ${f === startFret ? '3' : '1'}px solid ${borderColor}; position: relative;">`;
                    
                    // Chord position - show finger number or open string
                    if (isChordPosition) {
                        if (fingerNum === 0 && f === 0) {
                            // Open string - use a ring (green if detected)
                            html += `<div style="width: ${size}; height: ${size}; border-radius: 50%; background: transparent; border: 3px solid ${positionColor}; box-shadow: 0 0 10px ${glowColor};"></div>`;
                        } else {
                            // Fingered position - solid circle with number (green if detected)
                            html += `<div style="width: ${size}; height: ${size}; border-radius: 50%; background: ${bgColor}; box-shadow: 0 0 10px ${glowColor}; border: 2px solid var(--bg-primary); display: flex; align-items: center; justify-content: center; color: var(--bg-primary); font-weight: 700; font-size: 0.8rem;">${fingerNum}</div>`;
                        }
                    }
                    // Wrong note - show in red with X
                    else if (isWrongNote) {
                        html += `<div style="width: ${size}; height: ${size}; border-radius: 50%; background: ${bgColor}; box-shadow: 0 0 10px ${glowColor}; border: 2px solid var(--bg-primary); display: flex; align-items: center; justify-content: center; color: var(--bg-primary); font-weight: 700; font-size: 0.9rem;">‚úï</div>`;
                    }
                    // Muted string at nut
                    else if (isMuted && f === startFret && startFret === 0) {
                        html += `<div style="width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; color: var(--accent-danger); font-weight: 700; font-size: 1.2rem;">‚úï</div>`;
                    }
                    // Fret markers (only for relevant frets in the range)
                    else if (f > 0) {
                        const standardMarkers = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
                        const doubleMarkers = [12, 24];
                        
                        if (standardMarkers.includes(f) && s === Math.floor(numStrings / 2)) {
                            html += `<div style="width: 6px; height: 6px; border-radius: 50%; background: var(--text-secondary); opacity: 0.3;"></div>`;
                        } else if (doubleMarkers.includes(f) && (s === Math.floor(numStrings / 2) || s === Math.floor(numStrings / 2) - 1)) {
                            html += `<div style="width: 6px; height: 6px; border-radius: 50%; background: var(--text-secondary); opacity: 0.3;"></div>`;
                        }
                    }
                    
                    html += '</div>';
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            
            // Info display (same style as drawFretboard)
            html += `<div style="margin-top: 0.75rem; text-align: center; font-size: 0.85rem; color: var(--accent-primary); font-family: 'JetBrains Mono', monospace;">`;
            if (startFret === 0) {
                html += `Position de l'accord (cases 0-${endFret})`;
            } else {
                html += `Position de l'accord (cases ${startFret}-${endFret})`;
            }
            html += '</div>';
            
            // Legend
            html += `<div style="margin-top: 0.5rem; text-align: center; font-size: 0.75rem; color: var(--text-secondary); font-style: italic;">`;
            html += `üí° <span style="color: var(--accent-primary);">‚¨§ 1-4</span> = Doigt | <span style="color: var(--success);">‚óØ</span> = Corde √† vide | <span style="color: var(--accent-danger);">‚úï</span> = Muette`;
            html += '</div>';
            
            fretboardCanvas.innerHTML = html;
        }

        // Audio detection
        async function startAudioDetection() {
            try {
                // Only request microphone access if we don't have it yet
                if (!microphoneStream) {
                    microphoneStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    microphonePermissionGranted = true;
                }
                
                // Create new audio context if needed
                if (!audioContext || audioContext.state === 'closed') {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                // Create analyser and microphone node
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(microphoneStream);
                
                // Increase FFT size for better frequency resolution
                analyser.fftSize = 32768; // Doubled for even better bass frequency resolution (1.35 Hz per bin)
                analyser.smoothingTimeConstant = 0.6; // Increased smoothing for more stable signal (0 = no smoothing, 1 = max smoothing)
                
                // Add high-pass filter to remove low-frequency noise
                const highpass = audioContext.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 40; // Lowered to 40Hz to preserve E2 (82Hz) and D3 (146Hz)
                highpass.Q.value = 0.7; // Gentler slope to avoid attenuating low guitar frequencies
                
                // Connect: microphone ‚Üí highpass ‚Üí analyser
                microphone.connect(highpass);
                highpass.connect(analyser);
                
                isListening = true;
                statusIndicator.classList.add('active');
                statusText.textContent = 'Microphone actif';
                
                detectPitch();
                
                // Request wake lock to prevent screen from sleeping
                if ('wakeLock' in navigator) {
                    try {
                        wakeLock = await navigator.wakeLock.request('screen');
                        console.log('Wake Lock activ√© - l\'√©cran ne se mettra pas en veille');
                    } catch (err) {
                        console.log('Wake Lock non disponible:', err);
                    }
                }
            } catch (err) {
                console.error('Erreur microphone:', err);
                alert('Impossible d\'acc√©der au microphone');
                enableAudioCheckbox.checked = false;
                microphonePermissionGranted = false;
            }
        }

        function stopAudioDetection(fullStop = false) {
            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            // Only stop the stream if explicitly requested (checkbox unchecked)
            if (fullStop && microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
                microphoneStream = null;
                microphonePermissionGranted = false;
            }
            
            isListening = false;
            statusIndicator.classList.remove('active');
            statusText.textContent = 'Microphone d√©sactiv√©';
            detectedNoteEl.textContent = '‚Äî';
            detectedNoteEl.className = 'detected-note';
            lastDetectedNote = null;
            noteDetectionStartTime = 0;
            
            // Release wake lock
            if (wakeLock !== null) {
                wakeLock.release()
                    .then(() => {
                        wakeLock = null;
                        console.log('Wake Lock d√©sactiv√©');
                    });
            }
        }

        // ===== TUNER UTILITY FUNCTIONS =====
        
        function updateTuningReference() {
            const config = tuningConfigs[currentTuning];
            if (!config || !tuningReferenceContent) return;
            
            tuningReferenceContent.innerHTML = config.strings.map(s => `
                <div style="text-align: center; padding: 0.5rem; background: var(--bg-tertiary); border-radius: 4px;">
                    <div style="color: var(--accent-primary); font-weight: 600;">${s.note}</div>
                    <div style="color: var(--text-secondary); font-size: 0.65rem;">${s.freq.toFixed(1)}Hz</div>
                    <div style="color: var(--text-secondary); font-size: 0.6rem;">Corde ${s.string}</div>
                </div>
            `).join('');
        }
        
        function initGlobalTuner() {
            const config = tuningConfigs[currentTuning];
            if (!config || !stringsStatusGrid) return;
            
            // Build the grid of string status boxes
            stringsStatusGrid.innerHTML = config.strings.map(s => `
                <div id="string-status-${s.string}" style="text-align: center; padding: 0.75rem; background: var(--bg-tertiary); border-radius: 8px; border: 2px solid var(--border); transition: all 0.3s;">
                    <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 0.25rem;">Corde ${s.string}</div>
                    <div style="font-size: 1.1rem; font-weight: 700; color: var(--text-primary); margin-bottom: 0.25rem;">${s.note}</div>
                    <div id="string-freq-${s.string}" style="font-size: 0.65rem; color: var(--text-secondary); margin-bottom: 0.5rem;">‚Äî</div>
                    <div id="string-status-icon-${s.string}" style="font-size: 1.5rem;">‚ö™</div>
                    <div id="string-cents-${s.string}" style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 0.25rem; font-family: 'JetBrains Mono', monospace;">‚Äî</div>
                </div>
            `).join('');
        }
        
        function updateGlobalTuner(detectedNotes) {
            const config = tuningConfigs[currentTuning];
            if (!config) return;
            
            let okCount = 0;
            const toAdjust = [];
            const detectedSummary = [];
            
            // Reset all strings to "not detected"
            config.strings.forEach(expectedString => {
                const box = document.getElementById(`string-status-${expectedString.string}`);
                const freqEl = document.getElementById(`string-freq-${expectedString.string}`);
                const iconEl = document.getElementById(`string-status-icon-${expectedString.string}`);
                const centsEl = document.getElementById(`string-cents-${expectedString.string}`);
                
                if (!box) return;
                
                // Find if this string was detected
                const detected = detectedNotes.find(d => {
                    // Match by note name (e.g., "D3" matches "D3")
                    return d.note === expectedString.note;
                });
                
                if (detected) {
                    const cents = 1200 * Math.log2(detected.frequency / expectedString.freq);
                    const absCents = Math.abs(cents);
                    
                    freqEl.textContent = `${detected.frequency.toFixed(1)} Hz`;
                    centsEl.textContent = `${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¬¢`;
                    
                    detectedSummary.push(`${expectedString.note} (${detected.frequency.toFixed(1)} Hz, ${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¬¢)`);
                    
                    if (absCents < 5) {
                        // Perfect tuning
                        okCount++;
                        iconEl.textContent = '‚úÖ';
                        box.style.borderColor = 'var(--accent-success)';
                        box.style.background = 'rgba(0, 212, 170, 0.1)';
                    } else if (absCents < 10) {
                        // Close
                        iconEl.textContent = '‚ö†Ô∏è';
                        box.style.borderColor = 'var(--accent-primary)';
                        box.style.background = 'var(--bg-tertiary)';
                        toAdjust.push(`‚Ä¢ ${expectedString.note} (corde ${expectedString.string}) : ${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¬¢ ‚Üí Ajustez l√©g√®rement`);
                    } else if (cents > 0) {
                        // Too sharp
                        iconEl.textContent = '‚¨ÜÔ∏è';
                        box.style.borderColor = 'var(--accent-warning)';
                        box.style.background = 'rgba(255, 180, 0, 0.1)';
                        toAdjust.push(`‚Ä¢ ${expectedString.note} (corde ${expectedString.string}) : +${cents.toFixed(1)}¬¢ ‚Üí <span style="color: var(--accent-warning);">Desserrez</span>`);
                    } else {
                        // Too flat
                        iconEl.textContent = '‚¨áÔ∏è';
                        box.style.borderColor = 'var(--accent-danger)';
                        box.style.background = 'rgba(255, 80, 80, 0.1)';
                        toAdjust.push(`‚Ä¢ ${expectedString.note} (corde ${expectedString.string}) : ${cents.toFixed(1)}¬¢ ‚Üí <span style="color: var(--accent-danger);">Tendez</span>`);
                    }
                } else {
                    // Not detected
                    freqEl.textContent = '‚Äî';
                    iconEl.textContent = '‚ö™';
                    centsEl.textContent = '‚Äî';
                    box.style.borderColor = 'var(--border)';
                    box.style.background = 'var(--bg-tertiary)';
                }
            });
            
            // Update detected notes summary
            if (detectedNotesContent) {
                if (detectedSummary.length > 0) {
                    detectedNotesContent.innerHTML = detectedSummary.join('<br>');
                } else {
                    detectedNotesContent.textContent = 'Aucune note d√©tect√©e';
                }
            }
            
            // Update strings to adjust
            if (stringsToAdjustContent) {
                if (toAdjust.length > 0) {
                    stringsToAdjustContent.innerHTML = toAdjust.join('<br>');
                } else if (detectedSummary.length === 0) {
                    stringsToAdjustContent.textContent = 'Grattez toutes les cordes...';
                } else {
                    stringsToAdjustContent.innerHTML = '<span style="color: var(--accent-success);">‚úÖ Toutes les cordes d√©tect√©es sont bien accord√©es !</span>';
                }
            }
            
            // Update progress
            if (globalTunerProgressCount) {
                globalTunerProgressCount.textContent = `${okCount}/6`;
                if (okCount === 6) {
                    globalTunerProgressCount.style.color = 'var(--accent-success)';
                    if (stringsToAdjustContent) {
                        stringsToAdjustContent.innerHTML = '<span style="color: var(--accent-success); font-size: 1.1rem;">üéâ Guitare parfaitement accord√©e !</span>';
                    }
                } else {
                    globalTunerProgressCount.style.color = 'var(--accent-primary)';
                }
            }
        }
        
        // ===== MAIN PITCH DETECTION LOOP =====
        
        function detectPitch() {
            if (!isListening) return;
            
            const bufferLength = analyser.fftSize;
            const buffer = new Float32Array(bufferLength);
            analyser.getFloatTimeDomainData(buffer);
            
            const frequency = autoCorrelate(buffer, audioContext.sampleRate);
            
            // If waiting for release, don't update detection display
            if (waitingForRelease) {
                if (frequency <= 0) {
                    // Note released, show new exercise
                    waitingForRelease = false;
                    updateDisplay();
                    detectedNoteEl.textContent = '‚Äî';
                    detectedNoteEl.className = 'detected-note';
                    lastDetectedNote = null;
                    noteDetectionStartTime = 0;
                }
                requestAnimationFrame(detectPitch);
                return;
            }
            
            // ===== TUNER MODE: Continuous note detection with cents display =====
            if (currentMode === 'tuner') {
                if (currentTunerType === 'single') {
                    // SINGLE STRING TUNER: FFT-based detection with sliding average
                    const now = Date.now();
                    
                    // Get FFT data
                    const fftData = getFFTData();
                    const { dataArray, bufferLength, nyquist } = fftData;
                    
                    // Find strongest peak in guitar range
                    let maxMagnitude = -Infinity;
                    let maxFrequency = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const magnitude = dataArray[i];
                        if (magnitude > tunerMinMagnitude) {
                            const frequency = (i * nyquist) / bufferLength;
                            
                            // Guitar range: 60-400 Hz
                            if (frequency >= 60 && frequency <= 400) {
                                if (magnitude > maxMagnitude) {
                                    maxMagnitude = magnitude;
                                    maxFrequency = frequency;
                                }
                            }
                        }
                    }
                    
                    // Add to history if valid
                    if (maxFrequency > 0 && maxMagnitude > tunerMinMagnitude) {
                        tunerFrequencyHistory.push({
                            timestamp: now,
                            frequency: maxFrequency,
                            magnitude: maxMagnitude
                        });
                    }
                    
                    // Clean old entries (older than 2 seconds)
                    tunerFrequencyHistory = tunerFrequencyHistory.filter(entry => 
                        now - entry.timestamp < tunerAverageWindow
                    );
                    
                    // Calculate weighted average (recent samples weighted more)
                    if (tunerFrequencyHistory.length > 0) {
                        let totalWeight = 0;
                        let weightedFreqSum = 0;
                        
                        tunerFrequencyHistory.forEach(entry => {
                            const age = now - entry.timestamp;
                            // Linear weight: recent = 1.0, old (2s ago) = 0.2
                            const ageWeight = 1.0 - (age / tunerAverageWindow) * 0.8;
                            // Magnitude weight: louder = more important
                            const magWeight = Math.pow(10, (entry.magnitude - maxMagnitude) / 20);
                            const weight = ageWeight * magWeight;
                            
                            weightedFreqSum += entry.frequency * weight;
                            totalWeight += weight;
                        });
                        
                        const averagedFrequency = weightedFreqSum / totalWeight;
                        const note = frequencyToNote(averagedFrequency);
                        
                        if (note) {
                            // Calculate cents deviation from perfect pitch
                            const noteFreq = noteToFrequency(note);
                            const cents = 1200 * Math.log2(averagedFrequency / noteFreq);
                            
                            // Store this detection for persistence
                            lastSingleTunerDetection = now;
                            lastSingleTunerNote = {
                                note: note,
                                frequency: averagedFrequency,
                                cents: cents,
                                sampleCount: tunerFrequencyHistory.length
                            };
                            
                            // Update display
                            tunerNoteName.textContent = note;
                            tunerFrequency.textContent = `${averagedFrequency.toFixed(1)} Hz`;
                            tunerCents.textContent = `${cents >= 0 ? '+' : ''}${cents.toFixed(1)}¬¢`;
                            
                            // Move needle (-50 to +50 cents range)
                            const needlePercent = Math.max(-50, Math.min(50, cents));
                            tunerNeedle.style.transform = `translateX(${needlePercent * 2}%)`;
                            
                            // Update status based on tuning accuracy
                            let statusHTML = '';
                            
                            if (Math.abs(cents) < 5) {
                                statusHTML = '‚úÖ <span style="color: var(--accent-success); font-weight: 600;">Parfaitement accord√© !</span>';
                                tunerNeedle.style.background = 'var(--accent-success)';
                                tunerNeedle.style.boxShadow = '0 0 15px var(--accent-success)';
                            } else if (Math.abs(cents) < 10) {
                                statusHTML = 'üëç <span style="color: var(--accent-primary); font-weight: 600;">Presque ! Ajustez l√©g√®rement</span>';
                                tunerNeedle.style.background = 'var(--accent-primary)';
                                tunerNeedle.style.boxShadow = '0 0 10px var(--accent-primary)';
                            } else if (cents > 0) {
                                statusHTML = '‚¨ÜÔ∏è <span style="color: var(--accent-warning); font-weight: 600;">Trop aigu - Desserrez la corde</span>';
                                tunerNeedle.style.background = 'var(--accent-warning)';
                                tunerNeedle.style.boxShadow = '0 0 10px var(--accent-warning)';
                            } else {
                                statusHTML = '‚¨áÔ∏è <span style="color: var(--accent-danger); font-weight: 600;">Trop grave - Tendez la corde</span>';
                                tunerNeedle.style.background = 'var(--accent-danger)';
                                tunerNeedle.style.boxShadow = '0 0 10px var(--accent-danger)';
                            }
                            
                            // Add sample count for debugging
                            const stability = tunerFrequencyHistory.length >= 20 ? 'üîí' : tunerFrequencyHistory.length >= 10 ? '‚ö°' : 'üì°';
                            tunerStatus.innerHTML = `<div style="font-size: 1rem;">${statusHTML} <span style="font-size: 0.75rem; color: var(--text-secondary);">${stability} ${tunerFrequencyHistory.length} √©chantillons</span></div>`;
                            
                            // Reset opacity
                            tunerNoteName.style.opacity = 1;
                            tunerFrequency.style.opacity = 1;
                            tunerCents.style.opacity = 1;
                        }
                    } else {
                        // No valid frequency detected - check if we should show persisted note
                        const timeSinceLastDetection = now - lastSingleTunerDetection;
                        
                        if (lastSingleTunerNote && timeSinceLastDetection < singleTunerPersistenceDuration) {
                            // Show persisted note (with slight opacity to indicate it's old)
                            const remainingTime = singleTunerPersistenceDuration - timeSinceLastDetection;
                            const fadeStart = 3000; // Start fading after 3 seconds
                            
                            tunerNoteName.textContent = lastSingleTunerNote.note;
                            tunerFrequency.textContent = `${lastSingleTunerNote.frequency.toFixed(1)} Hz`;
                            tunerCents.textContent = `${lastSingleTunerNote.cents >= 0 ? '+' : ''}${lastSingleTunerNote.cents.toFixed(1)}¬¢`;
                            
                            // Keep needle position
                            const needlePercent = Math.max(-50, Math.min(50, lastSingleTunerNote.cents));
                            tunerNeedle.style.transform = `translateX(${needlePercent * 2}%)`;
                            
                            // Apply fade effect if in fade period
                            if (timeSinceLastDetection > fadeStart) {
                                const fadeProgress = (timeSinceLastDetection - fadeStart) / (singleTunerPersistenceDuration - fadeStart);
                                const opacity = 1 - (fadeProgress * 0.5); // Fade from 1 to 0.5
                                tunerNoteName.style.opacity = opacity;
                                tunerFrequency.style.opacity = opacity;
                                tunerCents.style.opacity = opacity;
                            } else {
                                tunerNoteName.style.opacity = 1;
                                tunerFrequency.style.opacity = 1;
                                tunerCents.style.opacity = 1;
                            }
                            
                            // Update status to show it's persisted
                            let statusHTML = '';
                            const cents = lastSingleTunerNote.cents;
                            
                            if (Math.abs(cents) < 5) {
                                statusHTML = '‚úÖ <span style="color: var(--accent-success); font-weight: 600;">Parfaitement accord√© !</span>';
                                tunerNeedle.style.background = 'var(--accent-success)';
                                tunerNeedle.style.boxShadow = '0 0 15px var(--accent-success)';
                            } else if (Math.abs(cents) < 10) {
                                statusHTML = 'üëç <span style="color: var(--accent-primary); font-weight: 600;">Presque ! Ajustez l√©g√®rement</span>';
                                tunerNeedle.style.background = 'var(--accent-primary)';
                                tunerNeedle.style.boxShadow = '0 0 10px var(--accent-primary)';
                            } else if (cents > 0) {
                                statusHTML = '‚¨ÜÔ∏è <span style="color: var(--accent-warning); font-weight: 600;">Trop aigu - Desserrez la corde</span>';
                                tunerNeedle.style.background = 'var(--accent-warning)';
                                tunerNeedle.style.boxShadow = '0 0 10px var(--accent-warning)';
                            } else {
                                statusHTML = '‚¨áÔ∏è <span style="color: var(--accent-danger); font-weight: 600;">Trop grave - Tendez la corde</span>';
                                tunerNeedle.style.background = 'var(--accent-danger)';
                                tunerNeedle.style.boxShadow = '0 0 10px var(--accent-danger)';
                            }
                            
                            tunerStatus.innerHTML = `<div style="font-size: 1rem;">${statusHTML} <span style="font-size: 0.8rem; color: var(--text-secondary);">(${Math.ceil(remainingTime / 1000)}s)</span></div>`;
                        } else {
                            // No note detected and persistence expired - reset display
                            tunerNoteName.textContent = '‚Äî';
                            tunerFrequency.textContent = '‚Äî Hz';
                            tunerCents.textContent = '0¬¢';
                            tunerNeedle.style.transform = 'translateX(0)';
                            tunerNeedle.style.background = 'var(--accent-primary)';
                            tunerStatus.innerHTML = '<div style="font-size: 1rem; color: var(--text-secondary);">üé∏ Jouez une corde...</div>';
                            
                            // Reset opacity
                            tunerNoteName.style.opacity = 1;
                            tunerFrequency.style.opacity = 1;
                            tunerCents.style.opacity = 1;
                            
                            // Clear persisted note and history
                            lastSingleTunerNote = null;
                            tunerFrequencyHistory = [];
                        }
                    }
                } else {
                    // GLOBAL TUNER: Detect all strings with FFT
                    // Only update every 500ms to avoid too frequent updates
                    const now = Date.now();
                    if (now - lastGlobalTuningCheck < 500) {
                        requestAnimationFrame(detectPitch);
                        return;
                    }
                    lastGlobalTuningCheck = now;
                    
                    // Use FFT-based detection (same as chord mode)
                    const fftData = getFFTData();
                    const detectedNotes = detectChordFromFFT(fftData);
                    
                    // Convert to format with frequencies
                    const notesWithFreq = window.lastDetectedNotesWithFreq || [];
                    
                    updateGlobalTuner(notesWithFreq);
                }
                
                requestAnimationFrame(detectPitch);
                return; // Exit early, don't run other mode logic
            }
            
            // ===== DEBUG MODE: Handle separately, before note detection logic =====
            if (currentMode === 'debug') {
                const fftData = getFFTData();
                const maxMagnitude = Math.max(...fftData.dataArray);
                const minDb = parseInt(detectionSensitivityInput?.value || -60);
                const hasSound = fftData.dataArray.some(magnitude => magnitude > minDb);
                
                // Log periodically
                if (Date.now() % 2000 < 50) {
                    console.log(`üî¨ Debug mode tick: hasSound=${hasSound}, maxMag=${maxMagnitude.toFixed(1)}dB, scheduled=${debugCaptureScheduled}`);
                }
                
                if (!hasSound) {
                    // No sound - reset if not already captured
                    if (!debugCaptureScheduled) {
                        debugCaptureStartTime = 0;
                    }
                } else {
                    // Sound detected
                    const currentTime = Date.now();
                    
                    // Start timer on first sound (only if not already captured)
                    if (debugCaptureStartTime === 0 && !debugCaptureScheduled) {
                        debugCaptureStartTime = currentTime;
                        console.log('üî¨ Debug: Sound detected, starting timer');
                        if (debugStatus) {
                            debugStatus.textContent = 'üéµ Signal d√©tect√©, capture en cours...';
                            debugStatus.style.color = 'var(--accent-primary)';
                        }
                    }
                    
                    const timeSinceStart = currentTime - debugCaptureStartTime;
                    const captureDelay = parseInt(debugCaptureDelayInput?.value || 600);
                    
                    // Perform ONE capture after delay
                    if (!debugCaptureScheduled && timeSinceStart >= captureDelay) {
                        console.log(`üî¨ Debug: Capturing FFT after ${timeSinceStart}ms`);
                        debugCaptureScheduled = true;
                        
                        // Capture time domain data with user-configured duration
                        const bufferDuration = parseInt(debugBufferDurationSelect?.value || 743);
                        const bufferSamples = Math.floor(bufferDuration * 44.1); // Convert ms to samples at 44.1kHz
                        const actualBufferSize = Math.min(bufferSamples, analyser.fftSize);
                        
                        const timeDomainBuffer = new Float32Array(actualBufferSize);
                        analyser.getFloatTimeDomainData(timeDomainBuffer);
                        
                        console.log(`üî¨ Captured ${actualBufferSize} samples (${(actualBufferSize / 44.1).toFixed(1)}ms)`);
                        
                        captureDebugFFT(fftData, timeDomainBuffer);
                    }
                }
                
                requestAnimationFrame(detectPitch);
                return; // Exit early, don't run normal note detection
            }
            
            // ===== NORMAL NOTE DETECTION (for other modes) =====
            if (frequency > 0) {
                const note = frequencyToNote(frequency);
                const currentTime = Date.now();
                
                // Check if the note has changed
                if (note !== lastDetectedNote) {
                    // New note detected, reset timer and clear display
                    lastDetectedNote = note;
                    noteDetectionStartTime = currentTime;
                    hasAutoAdvanced = false; // Reset for new note (important for chord mode)
                    detectedNoteEl.textContent = '‚Äî';
                    detectedNoteEl.className = 'detected-note';
                } else {
                    // Same note, check if it's been stable
                    const elapsedTime = currentTime - noteDetectionStartTime;
                    
                    // Use shorter duration for chord mode (50ms) to detect fast strumming
                    const requiredDuration = (currentExercise && currentExercise.type === 'chord') ? 50 : stableNoteDuration;
                    
                    if (elapsedTime >= requiredDuration) {
                        // Note has been stable long enough, display it
                        detectedNoteEl.textContent = `${note} (${noteToFrench[note]})`;
                        
                        // Check if correct
                        if (currentExercise && currentExercise.type === 'single') {
                            if (note === currentExercise.notes[0].note) {
                                detectedNoteEl.className = 'detected-note correct';
                                
                                // Auto-advance DISABLED for debugging
                                // Use "Suivant" button to manually advance
                                // if (!hasAutoAdvanced) {
                                //     hasAutoAdvanced = true;
                                //     
                                //     // Increment speed mode score (only once per note)
                                //     incrementSpeedModeScore();
                                //     
                                //     const delayMs = speedModeActive ? 500 : parseFloat(advanceDelayInput.value) * 1000;
                                //     setTimeout(() => {
                                //         if (isListening) { // Only if still listening
                                //             generateExercise();
                                //             hasAutoAdvanced = false; // Reset for next note
                                //         }
                                //     }, delayMs);
                                // }
                            } else {
                                detectedNoteEl.className = 'detected-note incorrect';
                                // Reset hasAutoAdvanced to allow detection to continue
                                hasAutoAdvanced = false;
                            }
                        } else if (currentExercise && currentExercise.type === 'chord') {
                            // Chord mode: Analyze ONCE after strumming delay
                            const chordNotes = currentExercise.chord.notes;
                            const uniqueChordNotes = [...new Set(chordNotes)];
                            
                            // Quick check: is there any sound?
                            const fftData = getFFTData();
                            const maxMagnitude = Math.max(...fftData.dataArray);
                            const minDb = parseInt(detectionSensitivityInput?.value || -60);
                            const hasSound = fftData.dataArray.some(magnitude => magnitude > minDb);
                            
                            // DEBUG: Log sound detection
                            if (Date.now() % 1000 < 50) { // Log every ~1 second
                                console.log(`üîä Sound check: hasSound=${hasSound}, maxMag=${maxMagnitude.toFixed(1)}dB, chordAnalysisScheduled=${chordAnalysisScheduled}`);
                            }
                            
                            if (!hasSound) {
                                // No sound - keep results visible, don't reset analysis flag
                                detectedNoteEl.textContent = '‚Äî';
                                detectedNoteEl.className = 'detected-note';
                                chordNotesDetected = [];
                                wrongNotesPlayed = [];
                                wrongPositions = [];
                                
                                // DON'T reset chordAnalysisScheduled - block until "Suivant"
                                // Only reset timer if no analysis done yet
                                if (!chordAnalysisScheduled) {
                                    chordDetectionStartTime = 0;
                                    hasAutoAdvanced = false;
                                    
                                    // Only redraw if no analysis done yet (to show initial state)
                                    if (detectedChordEl) detectedChordEl.style.display = 'none';
                                    
                                    if (currentExercise.chord.expectedFrequencies) {
                                        drawSpectrum(currentExercise.chord.expectedFrequencies, fftData);
                                    }
                                }
                                // If analysis done (chordAnalysisScheduled = true), don't redraw anything
                                // This keeps the frozen spectrum and fretboard visible
                            } else {
                                // Sound detected
                                const currentTime = Date.now();
                                
                                // Start timer on first sound (only if not already analyzed)
                                if (chordDetectionStartTime === 0 && !chordAnalysisScheduled) {
                                    chordDetectionStartTime = currentTime;
                                    chordNotesValue.textContent = 'Grattez toutes les cordes...';
                                    console.log(`‚è±Ô∏è Chord detection started! Waiting ${parseInt(strumDelayInput.value)}ms...`);
                                }
                                // Don't overwrite the result message if analysis is done
                                else if (chordAnalysisScheduled) {
                                    // Analysis done - don't touch chordNotesValue, it has the result
                                }
                                
                                const timeSinceStart = currentTime - chordDetectionStartTime;
                                
                                // Get dynamic strum delay from settings
                                const chordAnalysisDelay = parseInt(strumDelayInput.value);
                                
                                // Perform ONE analysis after strum delay
                                if (!chordAnalysisScheduled && timeSinceStart >= chordAnalysisDelay) {
                                    console.log(`üé∏ ANALYZING CHORD NOW! (${timeSinceStart}ms elapsed)`);
                                    chordAnalysisScheduled = true;
                                    
                                    // Store FFT data for frozen spectrum display
                                    frozenFFTData = {
                                        dataArray: new Float32Array(fftData.dataArray),
                                        bufferLength: fftData.bufferLength,
                                        sampleRate: fftData.sampleRate,
                                        nyquist: fftData.nyquist
                                    };
                                    
                                    // ===== SINGLE FFT ANALYSIS =====
                                    const detectedNotes = detectChordFromFFT(fftData);
                                    const foundNotes = uniqueChordNotes.filter(note => detectedNotes.includes(note));
                                    
                                    console.log(`üéµ Chord Analysis:`);
                                    console.log(`  Expected notes: ${uniqueChordNotes.join(', ')}`);
                                    console.log(`  Detected notes: ${detectedNotes.join(', ')}`);
                                    console.log(`  Found notes (intersection): ${foundNotes.join(', ')}`);

                                    
                                    // Check if bass note (lowest expected frequency) is detected at the RIGHT FREQUENCY
                                    globalBassNoteMissing = false;
                                    globalMissingBassNote = null;
                                    
                                    if (currentExercise.chord.expectedFrequencies && currentExercise.chord.expectedFrequencies.length > 0 && window.lastDetectedNotesWithFreq) {
                                        // Find the lowest expected frequency (bass note)
                                        const sortedExpected = [...currentExercise.chord.expectedFrequencies].sort((a, b) => a.frequency - b.frequency);
                                        const bassFreq = sortedExpected[0];
                                        
                                        // Check if this bass note is detected at approximately the right frequency
                                        const bassDetected = window.lastDetectedNotesWithFreq.some(detected => {
                                            // Must be same note name
                                            if (detected.note !== bassFreq.note) return false;
                                            
                                            // Must be within ¬±10% of expected frequency (allows some tuning variance but not octaves)
                                            const freqRatio = detected.frequency / bassFreq.frequency;
                                            return freqRatio >= 0.9 && freqRatio <= 1.1;
                                        });
                                        
                                        if (!bassDetected) {
                                            globalBassNoteMissing = true;
                                            globalMissingBassNote = bassFreq.note;
                                            console.log(`‚ö†Ô∏è Bass note missing: ${bassFreq.note} at ${Math.round(bassFreq.frequency)}Hz`);
                                            
                                            // IMPORTANT: Remove bass note from foundNotes if detected at wrong octave
                                            // This ensures proper message display
                                            const bassNoteIndex = foundNotes.indexOf(bassFreq.note);
                                            if (bassNoteIndex !== -1) {
                                                foundNotes.splice(bassNoteIndex, 1);
                                            }
                                        }
                                    }
                                    
                                    // Chord is complete only if all notes found AND bass note present at right frequency
                                    const chordComplete = foundNotes.length >= uniqueChordNotes.length && !globalBassNoteMissing;
                                    
                                    if (detectedNotes.length > 0) {
                                        const sortedDetectedNotes = sortNotesByPitch(detectedNotes);
                                        const sortedFoundNotes = sortNotesByPitch(foundNotes);
                                        
                                        // Identify wrong notes
                                        wrongNotesPlayed = sortedDetectedNotes.filter(note => !uniqueChordNotes.includes(note));
                                        
                                        // Identify chord played
                                        const identifiedChord = identifyChord(sortedDetectedNotes);
                                        
                                        // Analyze finger errors
                                        const misplacedFingers = [];
                                        wrongPositions = [];
                                        
                                        if (wrongNotesPlayed.length > 0 || sortedFoundNotes.length < uniqueChordNotes.length) {
                                            const instrument = instrumentTunings[instrumentType.value];
                                            const expectedFrets = currentExercise.chord.frets;
                                            const missingNotes = uniqueChordNotes.filter(n => !sortedFoundNotes.includes(n));
                                            
                                            if (missingNotes.length > 0) {
                                                missingNotes.forEach(missingNote => {
                                                    for (let s = 0; s < expectedFrets.length; s++) {
                                                        if (expectedFrets[s] === -1) continue;
                                                        
                                                        const openNote = instrument.notes[s];
                                                        const openNoteIndex = allNotes.indexOf(openNote);
                                                        const expectedNoteIndex = (openNoteIndex + expectedFrets[s]) % 12;
                                                        const expectedNote = allNotes[expectedNoteIndex];
                                                        
                                                        if (expectedNote === missingNote) {
                                                            const openStringNote = allNotes[openNoteIndex];
                                                            let detectedOnThisString = null;
                                                            
                                                            if (sortedDetectedNotes.includes(openStringNote) && openStringNote !== expectedNote) {
                                                                detectedOnThisString = { fret: 0, note: openStringNote };
                                                            } else {
                                                                for (let fret = 1; fret <= 12; fret++) {
                                                                    const noteIndex = (openNoteIndex + fret) % 12;
                                                                    const noteAtFret = allNotes[noteIndex];
                                                                    if (sortedDetectedNotes.includes(noteAtFret) && noteAtFret !== expectedNote) {
                                                                        detectedOnThisString = { fret: fret, note: noteAtFret };
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            
                                                            if (detectedOnThisString) {
                                                                const fingerNum = currentExercise.chord.fingers[s];
                                                                const stringName = instrument.strings[s];
                                                                const errorType = (detectedOnThisString.fret === 0 && expectedFrets[s] > 0) ? 'missing_finger' : 'wrong_fret';
                                                                
                                                                misplacedFingers.push({
                                                                    string: stringName,
                                                                    stringIndex: s,
                                                                    expectedFret: expectedFrets[s],
                                                                    expectedNote: expectedNote,
                                                                    detectedFret: detectedOnThisString.fret,
                                                                    detectedNote: detectedOnThisString.note,
                                                                    finger: fingerNum,
                                                                    type: errorType
                                                                });
                                                                
                                                                wrongPositions.push({
                                                                    stringIndex: s,
                                                                    fret: detectedOnThisString.fret
                                                                });
                                                            }
                                                            break;
                                                        }
                                                    }
                                                });
                                            }
                                        }
                                        
                                        // Display results
                                        if (chordComplete) {
                                            // Correct chord
                                            detectedNoteEl.className = 'detected-note correct';
                                            chordNotesDetected = sortedFoundNotes;
                                            chordNotesValue.textContent = `‚úÖ Accord complet !`;
                                            
                                            if (detectedChordEl) detectedChordEl.style.display = 'none';
                                            
                                            // Always draw fretboard after analysis to keep it visible
                                            drawChordFretboard(currentExercise.chord);
                                            
                                            if (currentExercise.chord.expectedFrequencies) {
                                                drawSpectrum(currentExercise.chord.expectedFrequencies, frozenFFTData || fftData);
                                            }
                                            
                                            // Auto-advance DISABLED for debugging
                                            // Use "Suivant" button to manually advance
                                            // if (!hasAutoAdvanced) {
                                            //     hasAutoAdvanced = true;
                                            //     const delayMs = parseFloat(advanceDelayInput.value) * 1000;
                                            //     setTimeout(() => {
                                            //         if (isListening) {
                                            //             generateExercise();
                                            //             hasAutoAdvanced = false;
                                            //         }
                                            //     }, delayMs);
                                            // }
                                        } else {
                                            // Wrong or partial chord
                                            detectedNoteEl.className = 'detected-note';
                                            chordNotesDetected = sortedFoundNotes;
                                            
                                            // Show detected chord in red
                                            if (identifiedChord && detectedChordEl && sortedDetectedNotes.length >= 2) {
                                                detectedChordEl.textContent = identifiedChord;
                                                detectedChordEl.style.display = 'block';
                                            } else {
                                                if (detectedChordEl) detectedChordEl.style.display = 'none';
                                            }
                                            
                                            // Show appropriate message
                                            console.log(`üîß Message logic: globalBassNoteMissing=${globalBassNoteMissing}, detectedLength=${sortedDetectedNotes.length}, foundLength=${sortedFoundNotes.length}, uniqueLength=${uniqueChordNotes.length}, wrongNotes=${wrongNotesPlayed.join(',')}`);
                                            console.log(`üîß About to check: typeof globalBassNoteMissing=${typeof globalBassNoteMissing}, value=${globalBassNoteMissing}, truthiness=${!!globalBassNoteMissing}`);
                                            
                                            if (globalBassNoteMissing) {
                                                console.log(`  ‚Üí Entering BASS MISSING branch`);
                                                console.log(`  ‚Üí globalMissingBassNote = "${globalMissingBassNote}"`);
                                                // CRITICAL: Bass note missing - chord INCORRECT
                                                let message = `‚ùå Accord incorrect - Basse manquante: ${globalMissingBassNote}`;
                                                
                                                // Also show other missing notes if any
                                                const otherMissingNotes = uniqueChordNotes.filter(n => 
                                                    !sortedFoundNotes.includes(n) && n !== globalMissingBassNote
                                                );
                                                if (otherMissingNotes.length > 0) {
                                                    message += ` (aussi: ${otherMissingNotes.join(', ')})`;
                                                }
                                                
                                                // Show wrong notes if any
                                                if (wrongNotesPlayed.length > 0) {
                                                    message += ` ‚ö†Ô∏è Parasites: ${wrongNotesPlayed.join(', ')}`;
                                                }
                                                
                                                // Make sure the chord notes display is visible
                                                const chordNotesDisplay = document.getElementById('chordNotesDisplay');
                                                console.log(`üîß chordNotesDisplay:`, chordNotesDisplay, `display before:`, chordNotesDisplay?.style?.display);
                                                if (chordNotesDisplay) {
                                                    chordNotesDisplay.style.display = 'block';
                                                    console.log(`üîß Set to block! display after:`, chordNotesDisplay.style.display);
                                                }
                                                
                                                chordNotesValue.textContent = message;
                                            } else if (sortedDetectedNotes.length >= 3 && sortedFoundNotes.length < uniqueChordNotes.length) {
                                                // Other notes missing (not bass) - WARNING
                                                let message = `‚ö†Ô∏è Notes aigu√´s manquantes: ${uniqueChordNotes.filter(n => !sortedFoundNotes.includes(n)).join(', ')}`;
                                                
                                                // Show wrong notes if any
                                                if (wrongNotesPlayed.length > 0) {
                                                    message += ` ‚ö†Ô∏è Parasites: ${wrongNotesPlayed.join(', ')}`;
                                                }
                                                
                                                chordNotesValue.textContent = message;
                                            } else if (sortedDetectedNotes.length >= 3 && wrongNotesPlayed.length > 0) {
                                                // All expected notes found but with parasites
                                                let message = `‚ùå Accord incorrect`;
                                                
                                                // Show wrong notes
                                                message += ` - Notes parasites: ${wrongNotesPlayed.join(', ')}`;
                                                
                                                chordNotesValue.textContent = message;
                                            } else {
                                                const missingNotes = uniqueChordNotes.filter(n => !sortedFoundNotes.includes(n));
                                                const sortedMissingNotes = sortNotesByPitch(missingNotes);
                                                
                                                let message = '';
                                                if (sortedMissingNotes.length > 0) {
                                                    message = `Manquantes: ${sortedMissingNotes.join(', ')}`;
                                                } else {
                                                    message = `${sortedFoundNotes.length}/${uniqueChordNotes.length} notes`;
                                                }
                                                
                                                // Add wrong notes warning if present
                                                if (wrongNotesPlayed.length > 0) {
                                                    message += ` ‚ö†Ô∏è Parasites: ${wrongNotesPlayed.join(', ')}`;
                                                }
                                                
                                                chordNotesValue.textContent = message;
                                            }
                                            
                                            // Always draw fretboard after analysis to keep it visible
                                            drawChordFretboard(currentExercise.chord);
                                            
                                            if (currentExercise.chord.expectedFrequencies) {
                                                drawSpectrum(currentExercise.chord.expectedFrequencies, frozenFFTData || fftData);
                                            }
                                        }
                                    }
                                } else if (chordAnalysisScheduled && timeSinceStart >= chordTimeout) {
                                    // Timeout - reset
                                    detectedNoteEl.textContent = '‚Äî';
                                    detectedNoteEl.className = 'detected-note';
                                    chordNotesDetected = [];
                                    wrongNotesPlayed = [];
                                    wrongPositions = [];
                                    chordDetectionStartTime = 0;
                                    // DON'T reset chordAnalysisScheduled - stay blocked until "Suivant"
                                    // chordAnalysisScheduled = false;
                                    
                                    chordNotesValue.innerHTML = `<span style="color: var(--accent-danger); font-weight: 700; font-size: 1.1rem;">‚è±Ô∏è Temps √©coul√© - R√©essayez l'accord ${currentExercise.chord.displayName}</span>`;
                                    
                                    if (detectedChordEl) detectedChordEl.style.display = 'none';
                                    
                                    // Always draw fretboard to keep it visible
                                    drawChordFretboard(currentExercise.chord);
                                    
                                    if (currentExercise.chord.expectedFrequencies) {
                                        drawSpectrum(currentExercise.chord.expectedFrequencies, frozenFFTData || fftData);
                                    }
                                }
                            }
                        } else {
                            detectedNoteEl.className = 'detected-note';
                        }
                    }
                }
            } else {
                // No clear pitch detected, reset and clear display
                if (lastDetectedNote !== null) {
                    lastDetectedNote = null;
                    noteDetectionStartTime = 0;
                    detectedNoteEl.textContent = '‚Äî';
                    detectedNoteEl.className = 'detected-note';
                }
            }
            
            requestAnimationFrame(detectPitch);
        }

        function identifyChord(notes) {
            if (notes.length < 2) return null;
            
            // Sort notes to normalize
            const sortedNotes = sortNotesByPitch(notes);
            const noteSet = sortedNotes.join(',');
            
            // Common chord patterns (normalized to root position when possible)
            const chordDatabase = {
                // Major chords
                'C,E,G': 'C',
                'C#,F,G#': 'C#',
                'D,F#,A': 'D',
                'D#,G,A#': 'D#',
                'E,G#,B': 'E',
                'F,A,C': 'F',
                'F#,A#,C#': 'F#',
                'G,B,D': 'G',
                'G#,C,D#': 'G#',
                'A,C#,E': 'A',
                'A#,D,F': 'A#',
                'B,D#,F#': 'B',
                
                // Minor chords
                'C,D#,G': 'Cm',
                'C#,E,G#': 'C#m',
                'D,F,A': 'Dm',
                'D#,F#,A#': 'D#m',
                'E,G,B': 'Em',
                'F,G#,C': 'Fm',
                'F#,A,C#': 'F#m',
                'G,A#,D': 'Gm',
                'G#,B,D#': 'G#m',
                'A,C,E': 'Am',
                'A#,C#,F': 'A#m',
                'B,D,F#': 'Bm',
                
                // 7th chords (partial matches)
                'C,E,G,A#': 'C7',
                'D,F#,A,C': 'D7',
                'E,G#,B,D': 'E7',
                'F,A,C,D#': 'F7',
                'G,B,D,F': 'G7',
                'A,C#,E,G': 'A7',
                'B,D#,F#,A': 'B7',
                
                // Power chords (2 notes)
                'C,G': 'C5',
                'D,A': 'D5',
                'E,B': 'E5',
                'F,C': 'F5',
                'G,D': 'G5',
                'A,E': 'A5',
                
                // Suspended chords
                'C,F,G': 'Csus4',
                'D,G,A': 'Dsus4',
                'E,A,B': 'Esus4',
                'G,C,D': 'Gsus4',
                'A,D,E': 'Asus4'
            };
            
            // Check direct match
            if (chordDatabase[noteSet]) {
                return chordDatabase[noteSet];
            }
            
            // Check if it's an inversion (try all rotations)
            for (let i = 0; i < sortedNotes.length; i++) {
                const rotated = [...sortedNotes.slice(i), ...sortedNotes.slice(0, i)];
                const rotatedSet = rotated.join(',');
                if (chordDatabase[rotatedSet]) {
                    return chordDatabase[rotatedSet];
                }
            }
            
            // If not found, return notes
            return sortedNotes.join('-');
        }

        function sortNotesByPitch(notes) {
            // Define note order (C is lowest in each octave)
            const noteOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            
            // Convert notes to frequencies for sorting
            const notesWithFreq = notes.map(note => {
                const freq = noteToFrequency(note);
                return { note: note, frequency: freq };
            });
            
            // Sort by frequency (lowest first)
            notesWithFreq.sort((a, b) => a.frequency - b.frequency);
            
            // Return just the note names
            return notesWithFreq.map(n => n.note);
        }

        function getFFTData() {
            // Single FFT call - returns data to be reused
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Float32Array(bufferLength);
            analyser.getFloatFrequencyData(dataArray);
            const sampleRate = audioContext.sampleRate;
            const nyquist = sampleRate / 2;
            
            // Debug: Log FFT statistics occasionally
            if (Date.now() % 2000 < 50) { // Every ~2 seconds
                const validData = dataArray.filter(v => v > -100);
                if (validData.length > 0) {
                    const maxMag = Math.max(...validData);
                    const avgMag = validData.reduce((a, b) => a + b, 0) / validData.length;
                    console.log(`üìä FFT Stats: max=${maxMag.toFixed(1)}dB, avg=${avgMag.toFixed(1)}dB, bins=${bufferLength}`);
                }
            }
            
            return {
                dataArray,
                bufferLength,
                sampleRate,
                nyquist
            };
        }

        function detectChordFromFFT(fftData) {
            // Use pre-computed FFT data
            const { dataArray, bufferLength, nyquist } = fftData;
            
            // Find all peaks in the frequency spectrum
            const peaks = [];
            // Get dynamic sensitivity from user settings
            const minDb = parseInt(detectionSensitivityInput?.value || -60);
            const peakThreshold = 5; // Base threshold for peak detection
            
            for (let i = 2; i < bufferLength - 2; i++) {
                const frequency = (i * nyquist) / bufferLength;
                
                // SPECIAL CASE: D/D#/E string fundamentals (140-170 Hz) get lower threshold
                // This frequency range is often very weak compared to harmonics
                let dynamicMinDb = minDb;
                if (frequency >= 140 && frequency <= 170) {
                    dynamicMinDb = Math.min(minDb, -75); // Accept down to -75 dB for D3/D#3/E3 range
                }
                
                if (dataArray[i] > dynamicMinDb) {
                    // Dynamic peak threshold: lower for D/D#/E string range (more sensitive)
                    let dynamicPeakThreshold = peakThreshold;
                    if (frequency >= 140 && frequency <= 170) {
                        dynamicPeakThreshold = 3; // More sensitive in D/D#/E range
                    }
                    
                    // Check if this is a local maximum
                    if (dataArray[i] > dataArray[i-1] && 
                        dataArray[i] > dataArray[i-2] &&
                        dataArray[i] > dataArray[i+1] && 
                        dataArray[i] > dataArray[i+2]) {
                        
                        // Check if peak is strong enough
                        const avgNeighbors = (dataArray[i-2] + dataArray[i-1] + dataArray[i+1] + dataArray[i+2]) / 4;
                        if (dataArray[i] - avgNeighbors > dynamicPeakThreshold) {
                            
                            // Only consider frequencies in musical range (40Hz - 1000Hz)
                            // Lowered to 40Hz to better capture low E string and D string
                            if (frequency >= 40 && frequency <= 1000) {
                                peaks.push({
                                    frequency: frequency,
                                    magnitude: dataArray[i]
                                });
                            }
                        }
                    }
                }
            }
            
            // SPECIAL CASE: Force detection of D3 (147 Hz) if present but weak
            // This helps when D3 fundamental is real but not detected as a strong local peak
            const d3TargetFreq = 146.83;
            const d3Index = Math.round((d3TargetFreq * bufferLength) / nyquist);
            
            if (d3Index >= 0 && d3Index < bufferLength) {
                const d3Magnitude = dataArray[d3Index];
                
                // Check if there's energy at D3 frequency that wasn't caught as a peak
                if (d3Magnitude > minDb) {
                    const alreadyHasD3 = peaks.some(p => p.frequency >= 140 && p.frequency <= 155);
                    
                    if (!alreadyHasD3) {
                        // Check a small window around D3 for the actual peak
                        let maxInWindow = d3Magnitude;
                        let maxIndex = d3Index;
                        for (let offset = -3; offset <= 3; offset++) {
                            const idx = d3Index + offset;
                            if (idx >= 2 && idx < bufferLength - 2 && dataArray[idx] > maxInWindow) {
                                maxInWindow = dataArray[idx];
                                maxIndex = idx;
                            }
                        }
                        
                        const forcedFreq = (maxIndex * nyquist) / bufferLength;
                        console.log(`üîß FORCED D3 detection: ${forcedFreq.toFixed(1)}Hz at ${maxInWindow.toFixed(1)}dB (not caught as regular peak)`);
                        
                        peaks.push({
                            frequency: forcedFreq,
                            magnitude: maxInWindow
                        });
                    }
                }
            }
            
            // Sort peaks by frequency (lowest first)
            peaks.sort((a, b) => a.frequency - b.frequency);
            
            // Find maximum magnitude for relative filtering
            const maxMagnitude = Math.max(...peaks.map(p => p.magnitude));
            const magnitudeThreshold = 17; // dB - Increased to better filter strong harmonics (especially 3x)
            
            // BOOST LOW FREQUENCIES: Add virtual magnitude boost to favor fundamentals over harmonics
            // This helps when harmonics are stronger than the fundamental (common with D string)
            peaks.forEach(peak => {
                // Apply frequency-dependent boost: MUCH stronger for lower frequencies
                if (peak.frequency < 150) {
                    // Very low frequencies (E2, A2, low D3) get massive boost
                    peak.boostedMagnitude = peak.magnitude + 18;
                } else if (peak.frequency < 200) {
                    // Low frequencies (D3, G3) get +15dB boost
                    peak.boostedMagnitude = peak.magnitude + 15;
                } else if (peak.frequency < 250) {
                    // Mid-low frequencies (B3) get +10dB boost
                    peak.boostedMagnitude = peak.magnitude + 10;
                } else if (peak.frequency < 350) {
                    // Mid frequencies get +6dB boost
                    peak.boostedMagnitude = peak.magnitude + 6;
                } else {
                    // Higher frequencies get no boost
                    peak.boostedMagnitude = peak.magnitude;
                }
            });
            
            const maxBoostedMagnitude = Math.max(...peaks.map(p => p.boostedMagnitude));
            
            console.log(`üîä Max magnitude: ${maxMagnitude.toFixed(1)}dB, Max boosted: ${maxBoostedMagnitude.toFixed(1)}dB`);
            
            // Debug: Log all peaks found
            if (peaks.length > 0) {
                console.log(`üîç All peaks found: ${peaks.map(p => `${Math.round(p.frequency)}Hz (${p.magnitude.toFixed(1)}dB)`).join(', ')}`);
                
                // Special debug for D/D#/E string detection and octave
                const lowPeaks = peaks.filter(p => p.frequency >= 140 && p.frequency <= 170);
                const dOctavePeaks = peaks.filter(p => p.frequency >= 285 && p.frequency <= 302);
                
                if (lowPeaks.length > 0) {
                    const usedSpecialThreshold = lowPeaks.some(p => p.magnitude < -60 && p.magnitude >= -75);
                    console.log(`üéØ Low range (140-170Hz, D3/D#3/E3): ${lowPeaks.map(p => `${Math.round(p.frequency)}Hz (${p.magnitude.toFixed(1)}dB, boosted: ${p.boostedMagnitude.toFixed(1)}dB)`).join(', ')}${usedSpecialThreshold ? ' ‚ö° SPECIAL -75dB THRESHOLD USED' : ''}`);
                }
                if (dOctavePeaks.length > 0) {
                    console.log(`üéØ D4 octave range (285-302Hz): ${dOctavePeaks.map(p => `${Math.round(p.frequency)}Hz (${p.magnitude.toFixed(1)}dB, boosted: ${p.boostedMagnitude.toFixed(1)}dB)`).join(', ')}`);
                }
                
                // Check if D4 is stronger than low fundamentals (problematic case)
                if (lowPeaks.length > 0 && dOctavePeaks.length > 0) {
                    const lowMag = lowPeaks[0].magnitude;
                    const d4Mag = dOctavePeaks[0].magnitude;
                    const diff = d4Mag - lowMag;
                    if (diff > 5) {
                        console.log(`‚ö†Ô∏è WARNING: D4 octave (${Math.round(dOctavePeaks[0].frequency)}Hz) is ${diff.toFixed(1)}dB stronger than fundamental (${Math.round(lowPeaks[0].frequency)}Hz)! This may cause detection issues.`);
                    }
                }
            }
            
            // Filter out harmonics BUT KEEP OCTAVES: keep fundamentals + octaves
            const fundamentals = [];
            const harmonicTolerance = 0.015; // 1.5% tolerance - slightly relaxed for better D string detection
            
            for (let i = 0; i < peaks.length; i++) {
                const peak = peaks[i];
                let isHarmonic = false;
                let harmonicOf = null;
                
                // Check if this peak is a harmonic of any lower frequency peak
                for (let j = 0; j < fundamentals.length; j++) {
                    const fundamental = fundamentals[j];
                    
                    // Check harmonics 3x-10x (NOT 2x = octave)
                    for (let multiple = 3; multiple <= 10; multiple++) {
                        const expectedHarmonic = fundamental.frequency * multiple;
                        const diff = Math.abs(peak.frequency - expectedHarmonic) / expectedHarmonic;
                        
                        if (diff < harmonicTolerance) {
                            isHarmonic = true;
                            harmonicOf = { freq: fundamental.frequency, multiple: multiple };
                            console.log(`  üîç ${Math.round(peak.frequency)}Hz detected as ${multiple}x harmonic of ${Math.round(fundamental.frequency)}Hz (diff: ${(diff * 100).toFixed(2)}%)`);
                            break;
                        }
                    }
                    
                    if (isHarmonic) break;
                }
                
                if (!isHarmonic && peak.frequency > 300) {
                    console.log(`  üîç ${Math.round(peak.frequency)}Hz NOT detected as harmonic (fundamentals in list: ${fundamentals.map(f => Math.round(f.frequency) + 'Hz').join(', ')})`);
                }
                
                // MAGNITUDE FILTER: If harmonic AND weak, filter it
                if (isHarmonic && harmonicOf) {
                    // Use BOOSTED magnitude to better detect when harmonics are stronger than fundamentals
                    const magnitudeDiff = maxBoostedMagnitude - peak.boostedMagnitude;
                    
                    // Harmonique 3x (tierce) est particuli√®rement forte sur guitare - seuil TR√àS strict
                    // Harmonique 5x est aussi souvent forte - seuil strict aussi
                    let effectiveThreshold = magnitudeThreshold;
                    if (harmonicOf.multiple === 3) {
                        effectiveThreshold = 10; // Tr√®s strict pour 3x
                    } else if (harmonicOf.multiple === 5) {
                        effectiveThreshold = magnitudeThreshold - 2; // Un peu plus strict pour 5x
                    }
                    
                    if (magnitudeDiff > effectiveThreshold) {
                        // Weak harmonic - filter it
                        console.log(`  ‚ùå ${Math.round(peak.frequency)}Hz filtered (weak harmonic ${harmonicOf.multiple}x of ${Math.round(harmonicOf.freq)}Hz, ${magnitudeDiff.toFixed(1)}dB below max boosted, threshold: ${effectiveThreshold}dB)`);
                        continue; // Skip this peak
                    } else {
                        // Strong harmonic - might be a real note, keep it
                        console.log(`  ‚ö†Ô∏è ${Math.round(peak.frequency)}Hz kept despite being harmonic ${harmonicOf.multiple}x (strong: only ${magnitudeDiff.toFixed(1)}dB below max boosted, threshold: ${effectiveThreshold}dB)`);
                    }
                }
                
                // If we reach here, the peak passed all filters - add it
                // BEFORE adding, check if this is a dominant octave that should be filtered
                let isDominantOctave = false;
                    for (let j = 0; j < fundamentals.length; j++) {
                        const lower = fundamentals[j];
                        const expectedOctave = lower.frequency * 2;
                        const diff = Math.abs(peak.frequency - expectedOctave) / expectedOctave;
                        if (diff < harmonicTolerance) {
                            // This is an octave
                            const octaveStronger = peak.magnitude - lower.magnitude;
                            if (octaveStronger > 15) {
                                // Octave is MUCH stronger - don't add it, keep the fundamental
                                console.log(`  ‚ùå OCTAVE FILTERED: ${Math.round(peak.frequency)}Hz is ${octaveStronger.toFixed(1)}dB stronger than fundamental ${Math.round(lower.frequency)}Hz - removing octave to keep fundamental`);
                                isDominantOctave = true;
                                break;
                            }
                        }
                    }
                    
                    // Only add if not a dominant octave
                    if (!isDominantOctave) {
                        fundamentals.push(peak);
                        
                        // Check if this is an octave of a lower fundamental (for logging)
                        let isOctave = false;
                        for (let j = 0; j < fundamentals.length - 1; j++) {
                            const lower = fundamentals[j];
                            const expectedOctave = lower.frequency * 2;
                            const diff = Math.abs(peak.frequency - expectedOctave) / expectedOctave;
                            if (diff < harmonicTolerance) {
                                isOctave = true;
                                const octaveStronger = peak.magnitude - lower.magnitude;
                                if (octaveStronger > 10) {
                                    console.log(`  ‚ö†Ô∏è OCTAVE DOMINANCE: ${Math.round(peak.frequency)}Hz is ${octaveStronger.toFixed(1)}dB stronger than fundamental ${Math.round(lower.frequency)}Hz - keeping both`);
                                } else {
                                    console.log(`  ‚úÖ ${Math.round(peak.frequency)}Hz kept (octave of ${Math.round(lower.frequency)}Hz, +${octaveStronger.toFixed(1)}dB)`);
                                }
                                break;
                            }
                        }
                        
                        if (!isOctave) {
                            console.log(`  ‚úÖ ${Math.round(peak.frequency)}Hz kept (fundamental, ${peak.magnitude.toFixed(1)}dB, boosted: ${peak.boostedMagnitude.toFixed(1)}dB)`);
                        }
                    }
            }
            
            // Convert frequencies to notes
            const detectedNotes = fundamentals.map(peak => {
                const note = frequencyToNote(peak.frequency);
                return { note: note, frequency: peak.frequency, magnitude: peak.magnitude };
            }).filter(n => n.note !== null);
            
            // Debug: Log frequency to note conversion
            if (detectedNotes.length > 0) {
                console.log(`üéµ Fundamentals ‚Üí Notes: ${detectedNotes.map(n => `${n.note} (${Math.round(n.frequency)}Hz)`).join(', ')}`);
            }
            
            // Remove duplicate notes (keep highest magnitude)
            const uniqueNotes = {};
            detectedNotes.forEach(n => {
                if (!uniqueNotes[n.note] || uniqueNotes[n.note].magnitude < n.magnitude) {
                    uniqueNotes[n.note] = n;
                }
            });
            
            // FILTER: Keep only the N strongest notes (to ignore sympathetic strings)
            const maxNotesLimit = parseInt(maxNotesDetectedSelect?.value || 0);
            let filteredNotes = Object.values(uniqueNotes);
            
            if (maxNotesLimit > 0 && filteredNotes.length > maxNotesLimit) {
                // Sort by magnitude (strongest first)
                filteredNotes.sort((a, b) => b.magnitude - a.magnitude);
                
                // Keep only top N
                const removed = filteredNotes.slice(maxNotesLimit);
                filteredNotes = filteredNotes.slice(0, maxNotesLimit);
                
                console.log(`üîá Filtered out weak notes (keeping ${maxNotesLimit} strongest): ${removed.map(n => `${n.note} (${n.magnitude.toFixed(1)}dB)`).join(', ')}`);
            }
            
            const finalNotes = filteredNotes.map(n => n.note);
            
            // Debug: Log final result
            if (finalNotes.length > 0) {
                console.log(`‚ú® Final detected notes: ${finalNotes.join(', ')}`);
            }
            console.log('---');
            
            // Store detected notes with frequencies globally for spectrum display
            window.lastDetectedNotesWithFreq = detectedNotes;
            
            return finalNotes;
        }

        function autoCorrelate(buffer, sampleRate) {
            let size = buffer.length;
            let maxSamples = Math.floor(size / 2);
            let bestOffset = -1;
            let bestCorrelation = 0;
            let rms = 0;
            
            // Calculate RMS (signal strength)
            for (let i = 0; i < size; i++) {
                let val = buffer[i];
                rms += val * val;
            }
            rms = Math.sqrt(rms / size);
            
            // Higher threshold to avoid weak signals and false positives
            if (rms < 0.03) return -1; // Increased from 0.02 to reduce false positives
            
            // Store all good correlations to find the strongest
            let correlations = [];
            let lastCorrelation = 1;
            
            for (let offset = 1; offset < maxSamples; offset++) {
                let correlation = 0;
                for (let i = 0; i < maxSamples; i++) {
                    correlation += Math.abs(buffer[i] - buffer[i + offset]);
                }
                correlation = 1 - (correlation / maxSamples);
                
                // Stricter threshold to avoid false detections
                if (correlation > 0.90 && correlation > lastCorrelation) { // Increased from 0.85 to 0.90
                    // Check if this is a local maximum
                    let isPeak = true;
                    for (let j = 1; j <= 3 && offset + j < maxSamples; j++) {
                        let futureCorr = 0;
                        for (let i = 0; i < maxSamples; i++) {
                            futureCorr += Math.abs(buffer[i] - buffer[i + offset + j]);
                        }
                        futureCorr = 1 - (futureCorr / maxSamples);
                        if (futureCorr > correlation) {
                            isPeak = false;
                            break;
                        }
                    }
                    
                    if (isPeak) {
                        correlations.push({
                            offset: offset,
                            correlation: correlation,
                            frequency: sampleRate / offset
                        });
                    }
                }
                lastCorrelation = correlation;
            }
            
            if (correlations.length === 0) return -1;
            
            // Sort by correlation strength (highest first)
            correlations.sort((a, b) => b.correlation - a.correlation);
            
            // Only accept if correlation is strong enough
            if (correlations[0].correlation < 0.92) return -1; // Add minimum quality threshold
            
            // Take the strongest correlation (most recent/loudest note)
            bestOffset = correlations[0].offset;
            bestCorrelation = correlations[0].correlation;
            
            // Parabolic interpolation for sub-sample accuracy
            if (bestOffset > 1 && bestOffset < maxSamples - 1) {
                let y1 = 0, y2 = 0, y3 = 0;
                
                // Recalculate correlation for neighboring offsets
                for (let i = 0; i < maxSamples; i++) {
                    y1 += Math.abs(buffer[i] - buffer[i + bestOffset - 1]);
                    y2 += Math.abs(buffer[i] - buffer[i + bestOffset]);
                    y3 += Math.abs(buffer[i] - buffer[i + bestOffset + 1]);
                }
                y1 = 1 - (y1 / maxSamples);
                y2 = 1 - (y2 / maxSamples);
                y3 = 1 - (y3 / maxSamples);
                
                let a = (y1 + y3) / 2 - y2;
                let b = (y3 - y1) / 2;
                
                if (a !== 0) {
                    let refinedOffset = bestOffset - b / (2 * a);
                    return sampleRate / refinedOffset;
                }
            }
            
            if (bestCorrelation > 0.01) {
                return sampleRate / bestOffset;
            }
            return -1;
        }

        function frequencyToNote(frequency) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const A4 = 440;
            const C0 = A4 * Math.pow(2, -4.75);
            
            if (frequency < 20) return null;
            
            const halfSteps = 12 * Math.log2(frequency / C0);
            const noteIndex = Math.round(halfSteps) % 12;
            
            return noteNames[noteIndex];
        }

        function noteToFrequency(noteName) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const A4 = 440;
            const C4 = 261.63; // Middle C
            
            const noteIndex = noteNames.indexOf(noteName);
            if (noteIndex === -1) return null;
            
            // Return frequency for the note in octave 4 (middle octave)
            const halfStepsFromC4 = noteIndex;
            return C4 * Math.pow(2, halfStepsFromC4 / 12);
        }
        
        // NEW: Convert note with octave (e.g., "E4", "D3") to frequency
        function noteWithOctaveToFrequency(noteNameWithOctave) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            
            // Parse note name and octave (e.g., "E4" -> "E", 4)
            const noteName = noteNameWithOctave.slice(0, -1);
            const octave = parseInt(noteNameWithOctave.slice(-1));
            
            if (isNaN(octave)) return null;
            
            const noteIndex = noteNames.indexOf(noteName);
            if (noteIndex === -1) return null;
            
            // Calculate frequency: A4 = 440 Hz as reference
            // Distance from A4 in semitones
            const A4Index = 9; // A is index 9 in noteNames
            const A4Octave = 4;
            
            const semitonesFromA4 = (octave - A4Octave) * 12 + (noteIndex - A4Index);
            const frequency = 440 * Math.pow(2, semitonesFromA4 / 12);
            
            return frequency;
        }


        function playNote(noteName, duration = 2000) {
            if (!playSoundCheckbox.checked) return;
            
            const frequency = noteToFrequency(noteName);
            if (!frequency) return;
            
            // Create audio context if not exists
            if (!audioContextSynth) {
                audioContextSynth = new (window.AudioContext || window.webkitAudioContext)();
            }
            
            const now = audioContextSynth.currentTime;
            const ctx = audioContextSynth;
            
            // Master gain for the complete sound
            const masterGain = ctx.createGain();
            
            // Body resonance filter (simulates guitar body)
            const bodyFilter = ctx.createBiquadFilter();
            bodyFilter.type = 'bandpass';
            bodyFilter.frequency.setValueAtTime(200, now); // Wood body resonance around 200Hz
            bodyFilter.Q.setValueAtTime(1, now);
            
            // Brightness filter (simulates tone control)
            const brightnessFilter = ctx.createBiquadFilter();
            brightnessFilter.type = 'lowpass';
            brightnessFilter.frequency.setValueAtTime(3500, now); // Cut high frequencies
            brightnessFilter.Q.setValueAtTime(0.7, now);
            
            // Subtle vibrato (LFO)
            const vibrato = ctx.createOscillator();
            const vibratoGain = ctx.createGain();
            vibrato.frequency.setValueAtTime(5, now); // 5Hz vibrato
            vibratoGain.gain.setValueAtTime(0, now);
            vibratoGain.gain.linearRampToValueAtTime(2, now + 0.5); // Vibrato fades in
            vibrato.connect(vibratoGain);
            
            // Guitar sound uses multiple harmonics with different amplitudes
            // Harmonics decay at different rates (inharmonicity)
            const harmonics = [
                { mult: 1.0, gain: 1.0, decay: 1.0 },      // Fundamental
                { mult: 2.0, gain: 0.6, decay: 0.9 },      // 2nd harmonic (octave)
                { mult: 3.0, gain: 0.4, decay: 0.8 },      // 3rd harmonic
                { mult: 4.0, gain: 0.25, decay: 0.7 },     // 4th harmonic
                { mult: 5.0, gain: 0.15, decay: 0.6 },     // 5th harmonic
                { mult: 6.0, gain: 0.1, decay: 0.5 },      // 6th harmonic
                { mult: 7.0, gain: 0.05, decay: 0.4 },     // 7th harmonic
                { mult: 8.0, gain: 0.03, decay: 0.3 }      // 8th harmonic
            ];
            
            harmonics.forEach((harmonic, index) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                // Use sine waves for each harmonic
                osc.type = 'sine';
                osc.frequency.setValueAtTime(frequency * harmonic.mult, now);
                
                // Connect vibrato to this oscillator
                vibratoGain.connect(osc.frequency);
                
                // Slightly detune higher harmonics (inharmonicity)
                if (index > 2) {
                    osc.detune.setValueAtTime(Math.random() * 4 - 2, now);
                }
                
                // Guitar-like ADSR envelope with individual decay rates
                const maxGain = 0.12 * harmonic.gain;
                gain.gain.setValueAtTime(0, now);
                
                // Attack - very fast pluck (slightly randomized per harmonic)
                const attackTime = 0.003 + (index * 0.001);
                gain.gain.linearRampToValueAtTime(maxGain, now + attackTime);
                
                // Decay - quick initial drop
                gain.gain.exponentialRampToValueAtTime(maxGain * 0.7, now + 0.04);
                
                // Sustain - gradual fade (higher harmonics fade faster)
                const sustainFactor = harmonic.decay;
                gain.gain.exponentialRampToValueAtTime(maxGain * 0.4 * sustainFactor, now + 0.3);
                gain.gain.exponentialRampToValueAtTime(maxGain * 0.2 * sustainFactor, now + 0.8);
                gain.gain.exponentialRampToValueAtTime(maxGain * 0.08 * sustainFactor, now + 1.5);
                
                // Release - final fade out
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration/1000);
                
                osc.connect(gain);
                gain.connect(bodyFilter);
                
                osc.start(now);
                osc.stop(now + duration/1000 + 0.1);
            });
            
            vibrato.start(now);
            vibrato.stop(now + duration/1000 + 0.1);
            
            // Add pluck attack noise (simulates pick hitting string)
            const bufferSize = ctx.sampleRate * 0.015; // 15ms of noise
            const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            
            // Filtered noise for realistic pluck
            for (let i = 0; i < bufferSize; i++) {
                const decay = 1 - (i / bufferSize);
                noiseData[i] = (Math.random() * 2 - 1) * 0.15 * decay;
            }
            
            const noiseSource = ctx.createBufferSource();
            noiseSource.buffer = noiseBuffer;
            
            const noiseGain = ctx.createGain();
            noiseGain.gain.setValueAtTime(0.4, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
            
            const noiseFilter = ctx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.setValueAtTime(frequency * 1.5, now);
            noiseFilter.Q.setValueAtTime(2, now);
            
            noiseSource.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(bodyFilter);
            
            noiseSource.start(now);
            noiseSource.stop(now + 0.015);
            
            // Add subtle string resonance (Karplus-Strong inspired)
            const stringResonance = ctx.createDelay();
            const stringFeedback = ctx.createGain();
            const stringFilter = ctx.createBiquadFilter();
            
            stringResonance.delayTime.setValueAtTime(1 / frequency, now);
            stringFeedback.gain.setValueAtTime(0.3, now);
            stringFilter.type = 'lowpass';
            stringFilter.frequency.setValueAtTime(frequency * 4, now);
            
            bodyFilter.connect(stringResonance);
            stringResonance.connect(stringFilter);
            stringFilter.connect(stringFeedback);
            stringFeedback.connect(stringResonance);
            
            // Final chain
            bodyFilter.connect(brightnessFilter);
            brightnessFilter.connect(masterGain);
            masterGain.connect(ctx.destination);
            
            // Master volume envelope
            masterGain.gain.setValueAtTime(0.8, now);
            masterGain.gain.setValueAtTime(0.8, now + duration/1000 - 0.1);
            masterGain.gain.linearRampToValueAtTime(0, now + duration/1000);
        }

        function frequencyToNote(frequency) {
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            const noteIndex = Math.round(noteNum) + 69;
            const octave = Math.floor(noteIndex / 12) - 1;
            const note = allNotes[noteIndex % 12];
            return note;
        }

        // Event listeners
        nextBtn.addEventListener('click', generateExercise);

        enableAudioCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                audioDetector.style.display = 'block';
                startAudioDetection();
            } else {
                audioDetector.style.display = 'none';
                stopAudioDetection(true); // Full stop - release the stream
            }
        });

        playSoundCheckbox.addEventListener('change', () => {
            // Just update the state, will be used when playing notes
            playNoteSound = playSoundCheckbox.checked;
        });

        // Update sensitivity value display
        if (detectionSensitivityInput) {
            detectionSensitivityInput.addEventListener('input', () => {
                sensitivityValueDisplay.textContent = `${detectionSensitivityInput.value} dB`;
            });
        }

        // Sync speed mode duration display when input changes
        speedModeDurationInput.addEventListener('change', () => {
            const duration = speedModeDurationInput.value;
            speedModeDurationDisplay.textContent = duration;
            speedModeTimer.textContent = duration;
        });

        // Chord mode controls
        chordTypeMajor.addEventListener('change', () => {
            availableChords = [];
            if (currentMode === 'chords') generateExercise();
        });

        chordTypeMinor.addEventListener('change', () => {
            availableChords = [];
            if (currentMode === 'chords') generateExercise();
        });

        chordsLevel.addEventListener('change', () => {
            availableChords = [];
            if (currentMode === 'chords') generateExercise();
        });

        showFretboardCheckbox.addEventListener('change', () => {
            if (showFretboardCheckbox.checked) {
                instrumentSelection.style.display = 'block';
                fretCountSelection.style.display = 'block';
                // Redraw fretboard with current exercise
                if (currentExercise) {
                    if (currentExercise.type === 'single') {
                        drawFretboard(currentExercise.notes[0].note);
                    } else if (currentExercise.type === 'chord') {
                        drawChordFretboard(currentExercise.chord);
                    }
                }
            } else {
                instrumentSelection.style.display = 'none';
                fretCountSelection.style.display = 'none';
                fretboardDisplay.style.display = 'none';
            }
        });

        instrumentType.addEventListener('change', () => {
            // Initialize enabled strings for new instrument
            initializeEnabledStrings();
            
            // Regenerate exercise to adapt to new instrument string count
            if (currentExercise) {
                generateExercise();
            }
        });

        fretCount.addEventListener('change', () => {
            // Redraw fretboard with new fret count
            if (showFretboardCheckbox.checked && currentExercise) {
                if (currentExercise.type === 'single') {
                    drawFretboard(currentExercise.notes[0].note);
                } else if (currentExercise.type === 'chord') {
                    drawChordFretboard(currentExercise.chord);
                }
            }
        });

        // Toggle settings panel
        let settingsVisible = true; // Start with settings open
        toggleSettingsBtn.addEventListener('click', () => {
            settingsVisible = !settingsVisible;
            if (settingsVisible) {
                settingsPanel.classList.remove('hidden');
                mainGrid.classList.remove('settings-hidden');
                toggleSettingsBtn.textContent = '‚öôÔ∏è';
                
                // Show overlay and disable display panel
                settingsOverlay.style.display = 'block';
                displayPanel.style.opacity = '0.3';
                displayPanel.style.pointerEvents = 'none';
                displayPanel.style.filter = 'blur(3px)';
                
                // Pause audio detection if active (but keep stream alive)
                if (isListening) {
                    stopAudioDetection(false); // Don't release the stream
                    // Remember it was active
                    window._wasListening = true;
                }
            } else {
                settingsPanel.classList.add('hidden');
                mainGrid.classList.add('settings-hidden');
                toggleSettingsBtn.textContent = '‚öôÔ∏è';
                
                // Hide overlay and enable display panel
                settingsOverlay.style.display = 'none';
                displayPanel.style.opacity = '1';
                displayPanel.style.pointerEvents = 'auto';
                displayPanel.style.filter = 'none';
                
                // Start audio detection if checkbox is enabled
                // (either resuming after pause, or starting for the first time)
                if (enableAudioCheckbox.checked && !isListening) {
                    audioDetector.style.display = 'block';
                    startAudioDetection();
                }
                
                // Clear the "was listening" flag
                window._wasListening = false;
            }
        });

        // Close settings when clicking outside the settings panel
        document.addEventListener('click', (e) => {
            // Only if settings are visible
            if (!settingsVisible) return;
            
            // Check if click is outside settings panel and not on toggle button
            const clickedInsideSettings = settingsPanel.contains(e.target);
            const clickedToggleButton = toggleSettingsBtn.contains(e.target);
            
            if (!clickedInsideSettings && !clickedToggleButton) {
                // Close settings (simulate button click)
                toggleSettingsBtn.click();
            }
        });




        // Reset chord pool when chord type selection changes

        // Fretboard visualization functions
        function initializeEnabledStrings() {
            const instrument = instrumentTunings[instrumentType.value];
            enabledStrings = {};
            instrument.strings.forEach((stringName, index) => {
                enabledStrings[index] = true; // All strings enabled by default
            });
        }
        
        function toggleString(stringIndex) {
            enabledStrings[stringIndex] = !enabledStrings[stringIndex];
            // Redraw fretboard
            if (currentExercise && currentExercise.type === 'single') {
                drawFretboard(currentExercise.notes[0].note);
            }
        }
        
        // Make toggleString accessible globally for onclick handlers
        window.toggleString = toggleString;
        
        function findNoteOnFretboard(noteName) {
            const instrument = instrumentTunings[instrumentType.value];
            const positions = [];
            const maxFret = parseInt(fretCount.value);
            
            // For each string (only if enabled)
            instrument.notes.forEach((openNote, stringIndex) => {
                if (!enabledStrings[stringIndex]) return; // Skip disabled strings
                
                // Find note positions on this string
                const openNoteIndex = allNotes.indexOf(openNote);
                const targetNoteIndex = allNotes.indexOf(noteName);
                
                // Calculate fret positions (considering octaves)
                for (let fret = 0; fret <= maxFret; fret++) {
                    const fretNoteIndex = (openNoteIndex + fret) % 12;
                    if (fretNoteIndex === targetNoteIndex) {
                        positions.push({
                            string: stringIndex,
                            fret: fret,
                            stringName: instrument.strings[stringIndex]
                        });
                    }
                }
            });
            
            return positions;
        }
        
        function drawFretboard(noteName) {
            if (!showFretboardCheckbox.checked) {
                fretboardDisplay.style.display = 'none';
                return;
            }
            
            fretboardDisplay.style.display = 'block';
            const positions = findNoteOnFretboard(noteName);
            const instrument = instrumentTunings[instrumentType.value];
            const numStrings = instrument.strings.length;
            const numFrets = parseInt(fretCount.value);
            
            // Adjust cell width based on number of frets for better visibility
            const cellWidth = numFrets <= 12 ? 50 : (numFrets <= 15 ? 45 : 40);
            const minWidth = (numFrets + 1) * cellWidth + 60; // +60 for string names
            
            // Build HTML for fretboard
            let html = `<div style="display: inline-block; min-width: ${minWidth}px; width: max-content;">`;
            
            // Fret numbers header
            html += '<div style="display: flex; align-items: center; margin-bottom: 0.25rem;">';
            html += '<div style="width: 50px;"></div>'; // Spacing for string names
            
            for (let fret = 0; fret <= numFrets; fret++) {
                html += `<div style="width: ${cellWidth}px; text-align: center; font-size: 0.7rem; color: var(--text-secondary); font-family: 'JetBrains Mono', monospace;">${fret}</div>`;
            }
            html += '</div>';
            
            // Draw strings (from high to low for visual clarity)
            for (let s = numStrings - 1; s >= 0; s--) {
                const isEnabled = enabledStrings[s];
                const opacity = isEnabled ? '1' : '0.3';
                
                html += '<div style="display: flex; align-items: center; margin-bottom: 0.5rem;">';
                
                // String name - clickable with French notation
                const stringNoteFr = instrument.notesFr[s];
                const stringNum = instrument.strings[s].match(/\d+/)[0]; // Extract octave number
                html += `<div onclick="toggleString(${s})" style="width: 50px; text-align: right; padding-right: 0.5rem; font-size: 0.8rem; color: ${isEnabled ? 'var(--accent-primary)' : 'var(--text-secondary)'}; font-family: 'JetBrains Mono', monospace; cursor: pointer; user-select: none; transition: all 0.2s;" title="Cliquer pour ${isEnabled ? 'd√©sactiver' : 'activer'}">${stringNoteFr}${stringNum}</div>`;
                
                // Frets
                for (let f = 0; f <= numFrets; f++) {
                    // Check if this position has the target note
                    const isHighlight = isEnabled && positions.some(pos => pos.string === s && pos.fret === f);
                    const bgColor = isHighlight ? 'var(--accent-primary)' : (f === 0 ? 'var(--bg-primary)' : 'transparent');
                    const borderColor = f === 0 ? 'var(--border)' : 'var(--text-secondary)';
                    const size = isHighlight ? '18px' : '10px';
                    
                    html += `<div style="width: ${cellWidth}px; height: 30px; display: flex; align-items: center; justify-content: center; border-left: ${f === 0 ? '3' : '1'}px solid ${borderColor}; position: relative; opacity: ${opacity};">`;
                    
                    if (isHighlight) {
                        html += `<div style="width: ${size}; height: ${size}; border-radius: 50%; background: ${bgColor}; box-shadow: 0 0 10px var(--accent-primary); border: 2px solid var(--bg-primary);"></div>`;
                    } else if (f > 0 && isEnabled) {
                        // Fret markers - adapted for different fretboard lengths
                        const standardMarkers = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
                        const doubleMarkers = [12, 24];
                        
                        if (standardMarkers.includes(f) && s === Math.floor(numStrings / 2)) {
                            html += `<div style="width: 6px; height: 6px; border-radius: 50%; background: var(--text-secondary); opacity: 0.3;"></div>`;
                        } else if (doubleMarkers.includes(f) && (s === Math.floor(numStrings / 2) || s === Math.floor(numStrings / 2) - 1)) {
                            html += `<div style="width: 6px; height: 6px; border-radius: 50%; background: var(--text-secondary); opacity: 0.3;"></div>`;
                        }
                    }
                    
                    html += '</div>';
                }
                
                html += '</div>';
            }
            
            html += '</div>';
            
            // Display info about number of positions
            const enabledCount = Object.values(enabledStrings).filter(v => v).length;
            html += `<div style="margin-top: 0.75rem; text-align: center; font-size: 0.85rem; color: var(--accent-primary); font-family: 'JetBrains Mono', monospace;">`;
            html += `${positions.length} position${positions.length > 1 ? 's' : ''} trouv√©e${positions.length > 1 ? 's' : ''} (${enabledCount}/${numStrings} cordes actives, ${numFrets} frettes)`;
            html += '</div>';
            
            html += `<div style="margin-top: 0.5rem; text-align: center; font-size: 0.75rem; color: var(--text-secondary); font-style: italic;">`;
            html += `üí° Cliquez sur le nom d'une corde pour l'activer/d√©sactiver`;
            html += '</div>';
            
            fretboardCanvas.innerHTML = html;
        }

        // Speed mode functions
        function startSpeedMode() {
            speedModeActive = true;
            speedModeCorrectCount = 0;
            speedModeTimeRemaining = parseInt(speedModeDurationInput.value);
            speedModeStartTime = Date.now();
            
            // Update UI
            speedModeScore.textContent = '0';
            speedModeTimer.textContent = speedModeTimeRemaining;
            speedModeStartBtn.textContent = '‚ñ† Arr√™ter';
            speedModeStartBtn.onclick = stopSpeedMode;
            
            // Make sure audio is enabled
            if (!enableAudioCheckbox.checked) {
                enableAudioCheckbox.checked = true;
                audioDetector.style.display = 'block';
                startAudioDetection();
            }
            
            // Start timer
            speedModeTimerInterval = setInterval(() => {
                speedModeTimeRemaining--;
                speedModeTimer.textContent = speedModeTimeRemaining;
                
                // Change color when time is running out
                if (speedModeTimeRemaining <= 10) {
                    speedModeTimer.style.color = 'var(--accent-danger)';
                } else if (speedModeTimeRemaining <= 30) {
                    speedModeTimer.style.color = 'var(--accent-warning)';
                }
                
                if (speedModeTimeRemaining <= 0) {
                    endSpeedMode();
                }
            }, 1000);
            
            // Generate first note
            generateExercise();
        }
        
        function stopSpeedMode() {
            speedModeActive = false;
            
            if (speedModeTimerInterval) {
                clearInterval(speedModeTimerInterval);
                speedModeTimerInterval = null;
            }
            
            // Reset UI
            speedModeTimeRemaining = parseInt(speedModeDurationInput.value);
            speedModeTimer.textContent = speedModeTimeRemaining;
            speedModeScore.textContent = '0';
            speedModeCorrectCount = 0;
            speedModeStartBtn.textContent = '‚ñ∂ D√©marrer le d√©fi';
            speedModeStartBtn.onclick = startSpeedMode;
            speedModeTimer.style.color = 'var(--accent-primary)';
        }
        
        function endSpeedMode() {
            // Save score BEFORE stopSpeedMode resets it
            const finalScore = speedModeCorrectCount;
            const timeElapsed = (Date.now() - speedModeStartTime) / 1000;
            const notesPerMinute = Math.round((finalScore / timeElapsed) * 60);
            
            stopSpeedMode();
            
            // Show final score with saved values
            alert(`üéâ D√©fi termin√© !\n\nScore : ${finalScore} notes correctes\nVitesse : ${notesPerMinute} notes/min`);
        }
        
        function incrementSpeedModeScore() {
            if (speedModeActive) {
                speedModeCorrectCount++;
                speedModeScore.textContent = speedModeCorrectCount;
            }
        }

        // Debug mode functions
        function resetDebugMode() {
            console.log('üî¨ Debug mode reset called');
            debugCaptureStartTime = 0;
            debugCaptureScheduled = false;
            debugFrozenFFT = null;
            waveformZoom = 1;
            waveformZoomY = 1;
            waveformOffset = 0;
            waveformOffsetY = 0;
            
            if (zoomLevel) zoomLevel.textContent = '1√ó';
            if (zoomYLevel) zoomYLevel.textContent = '1√ó';
            
            if (debugStatus) {
                debugStatus.textContent = 'üé§ En attente d\'un signal...';
                debugStatus.style.color = 'var(--text-secondary)';
            }
            
            if (debugStats) debugStats.style.display = 'none';
            if (debugPeakList) debugPeakList.style.display = 'none';
            
            // Clear waveform canvas
            if (debugWaveformCanvas) {
                const ctx = debugWaveformCanvas.getContext('2d');
                ctx.fillStyle = '#0a0e14';
                ctx.fillRect(0, 0, debugWaveformCanvas.width, debugWaveformCanvas.height);
            }
            
            // Clear spectrum canvas
            if (debugSpectrumCanvas) {
                const ctx = debugSpectrumCanvas.getContext('2d');
                ctx.fillStyle = '#0a0e14';
                ctx.fillRect(0, 0, debugSpectrumCanvas.width, debugSpectrumCanvas.height);
                console.log('üî¨ Canvas cleared');
            } else {
                console.error('‚ùå debugSpectrumCanvas not found!');
            }
        }
        
        function captureDebugFFT(fftData, timeDomainData) {
            console.log('üî¨ captureDebugFFT called', fftData);
            
            // Compute FFT on the captured time domain data
            if (timeDomainData) {
                console.log(`üî¨ Computing FFT on ${timeDomainData.length} samples...`);
                
                computeFFTFromWindow(timeDomainData, 0, timeDomainData.length).then(windowFFT => {
                    debugFrozenFFT = {
                        dataArray: windowFFT.dataArray,
                        bufferLength: windowFFT.bufferLength,
                        sampleRate: windowFFT.sampleRate,
                        nyquist: windowFFT.nyquist,
                        timeDomain: new Float32Array(timeDomainData)
                    };
                    
                    if (debugStatus) {
                        debugStatus.textContent = '‚úÖ Spectre captur√© !';
                        debugStatus.style.color = 'var(--success)';
                    }
                    
                    // Draw waveform first
                    console.log('üî¨ Drawing waveform...');
                    drawDebugWaveform(timeDomainData);
                    
                    // Draw spectrum
                    console.log('üî¨ Drawing spectrum...');
                    drawDebugSpectrum(debugFrozenFFT);
                    
                    // Analyze and display stats
                    console.log('üî¨ Analyzing FFT...');
                    analyzeDebugFFT(debugFrozenFFT);
                }).catch(error => {
                    console.error('‚ùå Error computing FFT:', error);
                });
            } else {
                // Fallback to original FFT data
                debugFrozenFFT = {
                    dataArray: new Float32Array(fftData.dataArray),
                    bufferLength: fftData.bufferLength,
                    sampleRate: fftData.sampleRate,
                    nyquist: fftData.nyquist,
                    timeDomain: null
                };
                
                if (debugStatus) {
                    debugStatus.textContent = '‚úÖ Spectre captur√© !';
                    debugStatus.style.color = 'var(--success)';
                }
                
                drawDebugSpectrum(debugFrozenFFT);
                analyzeDebugFFT(debugFrozenFFT);
            }
        }
        
        function drawDebugWaveform(timeDomainData) {
            const canvas = debugWaveformCanvas;
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#0a0e14';
            ctx.fillRect(0, 0, width, height);
            
            // Draw center line (zero)
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            // Draw waveform with zoom and offset
            ctx.strokeStyle = '#00d4aa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const bufferLength = timeDomainData.length;
            
            // Calculate visible range based on zoom and offset (X axis - time)
            const samplesPerPixel = bufferLength / width / waveformZoom;
            const centerSample = bufferLength / 2 + waveformOffset;
            const startSample = Math.max(0, Math.floor(centerSample - (width / 2) * samplesPerPixel));
            const endSample = Math.min(bufferLength, Math.ceil(centerSample + (width / 2) * samplesPerPixel));
            
            const visibleSamples = endSample - startSample;
            const sliceWidth = width / visibleSamples;
            let x = 0;
            
            // Y axis scaling and offset
            const amplitudeScale = waveformZoomY;
            const amplitudeCenter = waveformOffsetY;
            
            for (let i = startSample; i < endSample; i++) {
                const v = timeDomainData[i];
                // Apply Y zoom and offset
                const scaledV = (v - amplitudeCenter) * amplitudeScale + amplitudeCenter;
                const y = (scaledV + 1) * height / 2;
                
                if (i === startSample) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                x += sliceWidth;
            }
            
            ctx.stroke();
            
            // Draw amplitude labels (adjusted for Y zoom)
            ctx.fillStyle = '#8b949e';
            ctx.font = '10px JetBrains Mono';
            const maxAmplitude = 1.0 / amplitudeScale;
            const centerAmplitude = amplitudeCenter;
            ctx.fillText(`+${maxAmplitude.toFixed(2)}`, 5, 15);
            ctx.fillText(`${centerAmplitude.toFixed(2)}`, 5, height / 2 - 5);
            ctx.fillText(`-${maxAmplitude.toFixed(2)}`, 5, height - 5);
            
            // Draw time scale (visible duration)
            const visibleDuration = visibleSamples / 44100;
            ctx.fillText(`${(visibleDuration * 1000).toFixed(1)}ms`, width - 60, height - 5);
            
            // Draw sample position info
            const sampleRate = 44100;
            const startTime = (startSample / sampleRate * 1000).toFixed(1);
            const endTime = (endSample / sampleRate * 1000).toFixed(1);
            ctx.fillText(`${startTime}-${endTime}ms`, width / 2 - 40, 15);
        }
        
        function computeFFTFromWindow(timeDomainData, startSample, endSample) {
            // Extract the visible window
            const windowLength = endSample - startSample;
            const windowData = timeDomainData.slice(startSample, endSample);
            
            // Pad to next power of 2 for FFT
            const fftSize = Math.pow(2, Math.ceil(Math.log2(windowLength)));
            const paddedData = new Float32Array(fftSize);
            
            // Copy data and apply Hann window to reduce spectral leakage
            for (let i = 0; i < windowLength; i++) {
                const hannWindow = 0.5 * (1 - Math.cos(2 * Math.PI * i / (windowLength - 1)));
                paddedData[i] = windowData[i] * hannWindow;
            }
            
            // Create offline audio context for FFT computation
            const offlineCtx = new OfflineAudioContext(1, fftSize, 44100);
            const buffer = offlineCtx.createBuffer(1, fftSize, 44100);
            buffer.getChannelData(0).set(paddedData);
            
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            
            const analyser = offlineCtx.createAnalyser();
            analyser.fftSize = fftSize;
            analyser.smoothingTimeConstant = 0;
            
            source.connect(analyser);
            source.start(0);
            
            // Get frequency data
            const frequencyData = new Float32Array(analyser.frequencyBinCount);
            
            // We need to render to get the analysis
            return offlineCtx.startRendering().then(() => {
                analyser.getFloatFrequencyData(frequencyData);
                
                return {
                    dataArray: frequencyData,
                    bufferLength: analyser.frequencyBinCount,
                    sampleRate: 44100,
                    nyquist: 22050,
                    fftSize: fftSize,
                    windowDuration: windowLength / 44100
                };
            });
        }
        
        function drawDebugSpectrum(fftData) {
            const canvas = debugSpectrumCanvas;
            const ctx = canvas.getContext('2d');
            const { dataArray, bufferLength, nyquist } = fftData;
            
            // Clear canvas
            ctx.fillStyle = '#0a0e14';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#30363d';
            ctx.lineWidth = 1;
            
            // Horizontal grid lines (dB levels)
            const dbLevels = [-80, -60, -40, -20, 0];
            dbLevels.forEach(db => {
                const y = canvas.height - ((db + 100) / 100) * canvas.height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#8b949e';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText(`${db}dB`, 5, y - 2);
            });
            
            // Draw spectrum
            ctx.strokeStyle = '#00d4aa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const minFreq = 40;
            const maxFreq = 1000;
            
            for (let i = 0; i < bufferLength; i++) {
                const frequency = (i * nyquist) / bufferLength;
                
                if (frequency >= minFreq && frequency <= maxFreq) {
                    const x = ((frequency - minFreq) / (maxFreq - minFreq)) * canvas.width;
                    const magnitude = dataArray[i];
                    const y = canvas.height - ((magnitude + 100) / 100) * canvas.height;
                    
                    if (i === 0 || frequency <= minFreq) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
            }
            
            ctx.stroke();
            
            // Draw frequency labels
            const freqLabels = [50, 100, 150, 200, 250, 300, 400, 500, 750, 1000];
            ctx.fillStyle = '#8b949e';
            ctx.font = '10px JetBrains Mono';
            freqLabels.forEach(freq => {
                const x = ((freq - minFreq) / (maxFreq - minFreq)) * canvas.width;
                ctx.fillText(`${freq}Hz`, x - 15, canvas.height - 5);
            });
        }
        
        // Helper function to get note name for a string/fret combination
        function getStringNote(string, fret) {
            const openStrings = {
                1: 'E4',  // 329.63 Hz
                2: 'B3',  // 246.94 Hz
                3: 'G3',  // 196.00 Hz
                4: 'D3',  // 146.83 Hz
                5: 'A2',  // 110.00 Hz
                6: 'E2'   // 82.41 Hz
            };
            
            const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const openNote = openStrings[string];
            
            // Parse the open note (e.g., "E4" -> note: E, octave: 4)
            const openNoteName = openNote.slice(0, -1);
            let openOctave = parseInt(openNote.slice(-1));
            
            // Find index of open note
            let noteIndex = notes.indexOf(openNoteName);
            
            // Add frets
            noteIndex += fret;
            
            // Handle octave changes
            while (noteIndex >= 12) {
                noteIndex -= 12;
                openOctave++;
            }
            
            return notes[noteIndex] + openOctave;
        }
        
        function analyzeDebugFFT(fftData) {
            const { dataArray, bufferLength, nyquist, sampleRate } = fftData;
            const minDb = parseInt(detectionSensitivityInput?.value || -60);
            
            // Find all peaks
            const peaks = [];
            for (let i = 2; i < bufferLength - 2; i++) {
                const frequency = (i * nyquist) / bufferLength;
                
                // SPECIAL CASE: D/D#/E string fundamentals (140-170 Hz) get lower threshold
                let dynamicMinDb = minDb;
                if (frequency >= 140 && frequency <= 170) {
                    dynamicMinDb = Math.min(minDb, -75); // Accept down to -75 dB for D3/D#3/E3 range
                }
                
                if (dataArray[i] > dynamicMinDb) {
                    if (dataArray[i] > dataArray[i-1] && 
                        dataArray[i] > dataArray[i-2] &&
                        dataArray[i] > dataArray[i+1] && 
                        dataArray[i] > dataArray[i+2]) {
                        
                        if (frequency >= 40 && frequency <= 1000) {
                            peaks.push({
                                frequency: frequency,
                                magnitude: dataArray[i]
                            });
                        }
                    }
                }
            }
            
            // Sort by frequency (low to high) for chronological/harmonic analysis
            // This shows the fundamental first, then harmonics in order
            peaks.sort((a, b) => a.frequency - b.frequency);
            
            // FILTER PARASITIC PEAKS IN BOOSTED ZONES
            // In zones where we apply special boost (like 140-170 Hz for D string),
            // keep only the strongest peak to avoid detecting noise as multiple notes
            const boostedZones = [
                { min: 140, max: 170, name: 'D3/D#3/E3 zone' }
                // Add more zones here if needed
            ];
            
            const filteredPeaks = [];
            const peaksToSkip = new Set();
            
            boostedZones.forEach(zone => {
                const peaksInZone = peaks.filter(p => 
                    p.frequency >= zone.min && 
                    p.frequency <= zone.max &&
                    !peaksToSkip.has(p)
                );
                
                if (peaksInZone.length > 1) {
                    // Sort by magnitude (strongest first)
                    peaksInZone.sort((a, b) => b.magnitude - a.magnitude);
                    
                    // Keep only the strongest
                    const strongest = peaksInZone[0];
                    console.log(`üîß Boosted zone ${zone.name} (${zone.min}-${zone.max} Hz): ${peaksInZone.length} peaks found`);
                    console.log(`   ‚Üí Keeping strongest: ${strongest.frequency.toFixed(1)} Hz @ ${strongest.magnitude.toFixed(1)} dB`);
                    
                    // Mark others for removal
                    for (let i = 1; i < peaksInZone.length; i++) {
                        peaksToSkip.add(peaksInZone[i]);
                        console.log(`   ‚Üí Removing parasite: ${peaksInZone[i].frequency.toFixed(1)} Hz @ ${peaksInZone[i].magnitude.toFixed(1)} dB`);
                    }
                }
            });
            
            // Build final filtered list
            peaks.forEach(p => {
                if (!peaksToSkip.has(p)) {
                    filteredPeaks.push(p);
                }
            });
            
            // Replace peaks with filtered version
            const originalPeakCount = peaks.length;
            peaks.length = 0;
            peaks.push(...filteredPeaks);
            
            if (originalPeakCount !== peaks.length) {
                console.log(`üîß Filtered ${originalPeakCount - peaks.length} parasitic peak(s) from boosted zones`);
            }
            
            // Update stats - find max magnitude for stats display
            const maxMagnitudePeak = peaks.reduce((max, p) => p.magnitude > max.magnitude ? p : max, peaks[0] || {magnitude: 0, frequency: 0});
            
            const resolution = sampleRate / (bufferLength * 2);
            debugResolution.textContent = `${resolution.toFixed(2)} Hz/bin`;
            debugPeakCount.textContent = peaks.length;
            
            if (peaks.length > 0) {
                debugMaxPeak.textContent = `${Math.round(maxMagnitudePeak.frequency)} Hz`;
                debugMaxMagnitude.textContent = `${maxMagnitudePeak.magnitude.toFixed(1)} dB`;
            } else {
                debugMaxPeak.textContent = '‚Äî';
                debugMaxMagnitude.textContent = '‚Äî';
            }
            
            // Show stats
            debugStats.style.display = 'block';
            
            // Display peak list with harmonic detection
            if (peaks.length > 0) {
                const peakListHTML = peaks.slice(0, 30).map((peak, i) => {
                    const note = frequencyToNote(peak.frequency);
                    let harmonicInfo = '';
                    let bestMatch = null;
                    let bestRatio = Infinity;
                    
                    // Check if this peak is a harmonic of a previous (lower) peak
                    // Find the SIMPLEST harmonic relationship (lowest multiplier)
                    for (let j = 0; j < i; j++) {
                        const lowerPeak = peaks[j];
                        const ratio = peak.frequency / lowerPeak.frequency;
                        
                        // Check for common harmonic relationships (2x, 3x, 4x, etc.)
                        for (let mult = 2; mult <= 10; mult++) {
                            if (Math.abs(ratio - mult) < 0.05) { // 5% tolerance
                                // Keep only the simplest relationship (smallest multiplier)
                                if (mult < bestRatio) {
                                    bestRatio = mult;
                                    bestMatch = {
                                        mult: mult,
                                        freq: lowerPeak.frequency,
                                        note: frequencyToNote(lowerPeak.frequency)
                                    };
                                }
                                break; // Found a match for this peak, check next lowerPeak
                            }
                        }
                    }
                    
                    if (bestMatch) {
                        harmonicInfo = ` <span style="color: var(--accent-warning);">[${bestMatch.mult}√ó de ${Math.round(bestMatch.freq)}Hz ${bestMatch.note}]</span>`;
                    }
                    
                    // Mark if this is low range (D/D#/E) and used special threshold
                    const isLowRange = peak.frequency >= 140 && peak.frequency <= 170;
                    const usedSpecialThreshold = isLowRange && peak.magnitude < -60 && peak.magnitude >= -75;
                    const lowRangeMarker = usedSpecialThreshold ? ' <span style="color: var(--accent-success);">‚ö°-75dB</span>' : '';
                    
                    return `${(i+1).toString().padStart(2, ' ')}. ${Math.round(peak.frequency).toString().padEnd(4, ' ')} Hz ‚Üí ${peak.magnitude.toFixed(1).padStart(6, ' ')} dB ‚Üí <strong>${note || '?'}</strong>${harmonicInfo}${lowRangeMarker}`;
                }).join('<br>');
                
                // Ne PAS afficher tout de suite - on affichera dans le bon ordre √† la fin
                // debugPeakListContent.innerHTML = peakListHTML;
                let storedPeakListHTML = peakListHTML; // Stocker pour affichage ult√©rieur
                debugPeakList.style.display = 'block';
                
                // FRETBOARD POSITION DETECTION: Map detected notes to fret positions
                // STRATEGY: For EACH of the 6 strings, find the best matching peak
                // Assumes all strings are played (or at least try to find them)
                
                console.log(`üéº Total peaks available: ${peaks.length}`);
                console.log(`üéº Peak frequencies: ${peaks.slice(0, 15).map(p => `${p.frequency.toFixed(1)}Hz@${p.magnitude.toFixed(1)}dB`).join(', ')}`);
                
                
                const fretboardPositions = [];
                let lastAssignedFret = null;
                
                // NEW ALGORITHM: Classify peaks as FUNDAMENTAL or HARMONIC, then assign sequentially
                console.log(`\nüé∏ Classification and sequential assignment:`);
                
                let currentStringIndex = 6; // Start from bass (string 6)
                
                // STEP 1: Classify each peak as FUNDAMENTAL or HARMONIC
                console.log(`\nüìä Step 1: Classifying peaks...`);
                const classifiedPeaks = peaks.map((peak, index) => {
                    // Check if this peak is a harmonic (2√ó, 3√ó, 4√ó, 5√ó, 6√ó) of any previous peak
                    let isFundamental = true;
                    let harmonicOf = null;
                    let harmonicMultiple = null;
                    
                    for (let i = 0; i < index; i++) {
                        const prevPeak = peaks[i];
                        for (let mult = 2; mult <= 6; mult++) {
                            const expectedHarmonic = prevPeak.frequency * mult;
                            const tolerance = expectedHarmonic * 0.02; // 2% tolerance
                            
                            if (Math.abs(peak.frequency - expectedHarmonic) < tolerance) {
                                isFundamental = false;
                                harmonicOf = prevPeak.frequency;
                                harmonicMultiple = mult;
                                break;
                            }
                        }
                        if (!isFundamental) break;
                    }
                    
                    const classification = isFundamental ? 'FUNDAMENTAL' : 'HARMONIC';
                    const detail = isFundamental ? '' : ` (${harmonicMultiple}√ó of ${harmonicOf.toFixed(1)}Hz)`;
                    console.log(`  ${peak.frequency.toFixed(1)}Hz @ ${peak.magnitude.toFixed(1)}dB ‚Üí ${classification}${detail}`);
                    
                    return {
                        ...peak,
                        isFundamental,
                        harmonicOf,
                        harmonicMultiple
                    };
                });
                
                // STEP 2: Process peaks sequentially from bass to treble
                console.log(`\nüé∏ Step 2: Assigning peaks to strings...`);
                
                for (const peak of classifiedPeaks) {
                    if (currentStringIndex < 1) {
                        console.log(`\n‚úÖ All 6 strings assigned, stopping.`);
                        break; // All strings assigned
                    }
                    
                    console.log(`\nüéµ Processing ${peak.frequency.toFixed(1)}Hz (${peak.isFundamental ? 'FUNDAMENTAL' : 'HARMONIC'}):`);
                    
                    // Get the frequency range for current string
                    const openNote = getStringNote(currentStringIndex, 0);
                    const maxFretNote = getStringNote(currentStringIndex, 12);
                    const minFreq = noteWithOctaveToFrequency(openNote);
                    const maxFreq = noteWithOctaveToFrequency(maxFretNote);
                    const tolerance = 3.0; // Hz
                    
                    // Check if peak is in range for this string
                    if (peak.frequency < (minFreq - tolerance) || peak.frequency > (maxFreq + tolerance)) {
                        console.log(`  ‚è≠Ô∏è Out of range for String ${currentStringIndex} (${minFreq.toFixed(1)}-${maxFreq.toFixed(1)}Hz)`);
                        continue; // Skip this peak, try next one
                    }
                    
                    console.log(`  ‚úÖ In range for String ${currentStringIndex} (${minFreq.toFixed(1)}-${maxFreq.toFixed(1)}Hz)`);
                    
                    // Find which fret this peak matches
                    let bestMatch = null;
                    let bestDiff = Infinity;
                    
                    for (let fret = 0; fret <= 12; fret++) {
                        const fretNote = getStringNote(currentStringIndex, fret);
                        const fretFreq = noteWithOctaveToFrequency(fretNote);
                        const freqDiff = Math.abs(peak.frequency - fretFreq);
                        const freqTolerance = fretFreq * 0.03; // 3% tolerance
                        
                        if (freqDiff < freqTolerance && freqDiff < bestDiff) {
                            bestDiff = freqDiff;
                            bestMatch = {
                                fret: fret,
                                note: fretNote,
                                theoreticalFreq: fretFreq,
                                freqDiff: freqDiff,
                                cents: 1200 * Math.log2(peak.frequency / fretFreq)
                            };
                        }
                    }
                    
                    if (!bestMatch) {
                        console.log(`  ‚ùå No valid fret match`);
                        continue;
                    }
                    
                    // Check GLOBAL SPAN constraint (max 4 frets between lowest and highest finger)
                    if (fretboardPositions.length > 0) {
                        const currentFrets = fretboardPositions.map(p => p.fret);
                        const minFret = Math.min(...currentFrets);
                        const maxFret = Math.max(...currentFrets);
                        
                        // Calculate what the span would be if we add this new fret
                        const newSpan = Math.max(maxFret, bestMatch.fret) - Math.min(minFret, bestMatch.fret);
                        
                        if (newSpan > 4) {
                            console.log(`  ‚ö†Ô∏è Adding fret ${bestMatch.fret} would create span ${newSpan} > 4 (current: ${minFret}-${maxFret})`);
                            continue; // Skip this peak - would create impossible hand position
                        }
                        console.log(`  ‚úÖ Fret ${bestMatch.fret} maintains span ‚â§ 4 (current: ${minFret}-${maxFret}, new: ${Math.min(minFret, bestMatch.fret)}-${Math.max(maxFret, bestMatch.fret)})`);
                    }
                    
                    // DECISION LOGIC:
                    if (peak.isFundamental) {
                        // FUNDAMENTAL ‚Üí Assign directly
                        const fretDisplay = bestMatch.fret === 0 ? '√Ä vide' : `Frette ${bestMatch.fret}`;
                        console.log(`  ‚úÖ FUNDAMENTAL ‚Üí Assigning to String ${currentStringIndex}: ${fretDisplay} = ${bestMatch.note}`);
                        
                        fretboardPositions.push({
                            string: currentStringIndex,
                            fret: bestMatch.fret,
                            note: bestMatch.note,
                            frequency: bestMatch.theoreticalFreq,
                            detectedFreq: peak.frequency,
                            diff: bestMatch.freqDiff,
                            cents: bestMatch.cents,
                            magnitude: peak.magnitude
                        });
                        
                        lastAssignedFret = bestMatch.fret;
                        currentStringIndex--; // Move to next string
                        
                    } else {
                        // HARMONIC ‚Üí Apply filter from v4.45.0
                        console.log(`  üîç HARMONIC ‚Üí Checking if it's a real played note...`);
                        
                        // Check if this harmonic has its own harmonics (2√ó and 3√ó)
                        const harmonic2x = peak.frequency * 2;
                        const harmonic3x = peak.frequency * 3;
                        
                        const has2x = peaks.find(p => Math.abs(p.frequency - harmonic2x) < harmonic2x * 0.02);
                        const has3x = peaks.find(p => Math.abs(p.frequency - harmonic3x) < harmonic3x * 0.02);
                        
                        let harmonicScore = 0;
                        if (has2x) {
                            harmonicScore += 2;
                            console.log(`    Has 2√ó harmonic at ${has2x.frequency.toFixed(1)}Hz ‚Üí score +2`);
                        }
                        if (has3x) {
                            harmonicScore += 1;
                            console.log(`    Has 3√ó harmonic at ${has3x.frequency.toFixed(1)}Hz ‚Üí score +1`);
                        }
                        
                        // Decision: assign if harmonic score >= 2 (has at least 2√ó harmonic)
                        if (harmonicScore >= 2) {
                            const fretDisplay = bestMatch.fret === 0 ? '√Ä vide' : `Frette ${bestMatch.fret}`;
                            console.log(`  ‚úÖ HARMONIC with strong harmonics (score ${harmonicScore}) ‚Üí Assigning to String ${currentStringIndex}: ${fretDisplay} = ${bestMatch.note}`);
                            
                            fretboardPositions.push({
                                string: currentStringIndex,
                                fret: bestMatch.fret,
                                note: bestMatch.note,
                                frequency: bestMatch.theoreticalFreq,
                                detectedFreq: peak.frequency,
                                diff: bestMatch.freqDiff,
                                cents: bestMatch.cents,
                                magnitude: peak.magnitude
                            });
                            
                            lastAssignedFret = bestMatch.fret;
                            currentStringIndex--; // Move to next string
                        } else {
                            console.log(`  ‚è≠Ô∏è HARMONIC with weak harmonics (score ${harmonicScore}) ‚Üí Skipping (likely parasitic)`);
                        }
                    }
                }
                
                console.log(`\nüéº Total positions found: ${fretboardPositions.length}/6`);
                
                // ============================================================
                // STRUCTURATION DE LA D√âTECTION (Option A - Bases solides)
                // ============================================================
                
                console.log(`\nüìä Structuring detection results...`);
                
                // 1. EXTRAIRE LES NOTES UNIQUES (sans octave)
                function extraireNotesUniques(positions) {
                    // IMPORTANT: Garder l'ordre des fr√©quences (grave ‚Üí aigu), pas alphab√©tique !
                    // Trier d'abord les positions par fr√©quence
                    const positionsSorted = [...positions].sort((a, b) => a.frequency - b.frequency);
                    
                    const notesUniques = [];
                    const notesSeen = new Set();
                    
                    positionsSorted.forEach(pos => {
                        // Enlever le chiffre d'octave (ex: "D3" ‚Üí "D")
                        const noteBase = pos.note.replace(/[0-9]/g, '');
                        if (!notesSeen.has(noteBase)) {
                            notesUniques.push(noteBase);
                            notesSeen.add(noteBase);
                        }
                    });
                    
                    return notesUniques; // Ordre: grave ‚Üí aigu
                }
                
                // 2. CALCULER LA ZONE DU MANCHE
                function calculerZone(positions) {
                    if (positions.length === 0) return 'unknown';
                    const frets = positions.map(p => p.fret);
                    const minFret = Math.min(...frets);
                    
                    if (minFret <= 3) return 'ouverte';
                    if (minFret <= 7) return 'basse';
                    if (minFret <= 10) return 'moyenne';
                    return 'haute';
                }
                
                // 3. CALCULER LE SPAN (√©tendue de frettes)
                function calculerSpan(positions) {
                    if (positions.length === 0) return 0;
                    const frets = positions.map(p => p.fret);
                    return Math.max(...frets) - Math.min(...frets);
                }
                
                // 4. CALCULER LE MATCH FFT (combien de positions matchent les pics)
                function calculerMatchFFT(positions, peaks) {
                    if (positions.length === 0) return 0;
                    
                    let matchCount = 0;
                    positions.forEach(pos => {
                        const freqTheorique = pos.frequency;
                        const tolerance = freqTheorique * 0.03; // 3%
                        
                        // Chercher un pic proche
                        const peakMatch = peaks.find(p => 
                            Math.abs(p.frequency - freqTheorique) < tolerance
                        );
                        
                        if (peakMatch) {
                            matchCount++;
                        }
                    });
                    
                    return matchCount / positions.length;
                }
                
                // 5. √âVALUER LA QUALIT√â DU SIGNAL
                function evaluerQualiteSignal(peaks) {
                    if (peaks.length === 0) return 'unknown';
                    
                    const magnitudes = peaks.map(p => p.magnitude);
                    const magnitudeMoyenne = magnitudes.reduce((a, b) => a + b, 0) / magnitudes.length;
                    
                    if (magnitudeMoyenne > -40) return 'excellent';
                    if (magnitudeMoyenne > -50) return 'bon';
                    if (magnitudeMoyenne > -60) return 'moyen';
                    return 'faible';
                }
                
                // 6. D√âTECTER LA QUALIT√â DE L'ACCORD (majeur/mineur/etc)
                function detecterQualite(notes) {
                    if (notes.length < 3) return 'incomplet';
                    
                    // Convertir les notes en demi-tons (C=0, C#=1, D=2, etc.)
                    const noteValues = {
                        'C': 0, 'C#': 1, 'Db': 1,
                        'D': 2, 'D#': 3, 'Eb': 3,
                        'E': 4,
                        'F': 5, 'F#': 6, 'Gb': 6,
                        'G': 7, 'G#': 8, 'Ab': 8,
                        'A': 9, 'A#': 10, 'Bb': 10,
                        'B': 11
                    };
                    
                    const values = notes.map(n => noteValues[n]).filter(v => v !== undefined);
                    if (values.length < 3) return 'unknown';
                    
                    // Trier les valeurs
                    values.sort((a, b) => a - b);
                    
                    // Calculer les intervalles depuis la racine
                    const root = values[0];
                    const intervalles = values.map(v => (v - root + 12) % 12);
                    
                    // D√©tecter le type d'accord
                    const hasThirdMajor = intervalles.includes(4);  // Tierce majeure
                    const hasThirdMinor = intervalles.includes(3);  // Tierce mineure
                    const hasFifth = intervalles.includes(7);       // Quinte juste
                    const hasSeventh = intervalles.includes(10);    // Septi√®me mineure
                    const hasMajorSeventh = intervalles.includes(11); // Septi√®me majeure
                    
                    if (hasThirdMajor && hasFifth && hasSeventh) return '7√®me dominante';
                    if (hasThirdMajor && hasFifth && hasMajorSeventh) return '7√®me majeure';
                    if (hasThirdMinor && hasFifth && hasSeventh) return '7√®me mineure';
                    if (hasThirdMajor && hasFifth) return 'majeur';
                    if (hasThirdMinor && hasFifth) return 'mineur';
                    
                    return 'autre';
                }
                
                // 7. D√âTECTER LA RACINE (note la plus grave)
                function detecterRacine(positions) {
                    if (positions.length === 0) return 'unknown';
                    
                    // Trouver la position avec la fr√©quence la plus basse
                    const plusGrave = positions.reduce((min, pos) => 
                        pos.frequency < min.frequency ? pos : min
                    );
                    
                    return plusGrave.note.replace(/[0-9]/g, ''); // Enlever l'octave
                }
                
                // 8. STRUCTURER TOUTE LA D√âTECTION
                const detectionStructuree = {
                    chord: {
                        root: detecterRacine(fretboardPositions),
                        quality: detecterQualite(extraireNotesUniques(fretboardPositions)),
                        notes: extraireNotesUniques(fretboardPositions)
                    },
                    
                    peaks: {
                        fundamentals: classifiedPeaks.filter(p => p.isFundamental),
                        harmonics: classifiedPeaks.filter(p => !p.isFundamental),
                        all: peaks
                    },
                    
                    currentPosition: {
                        strings: fretboardPositions.map(p => p.string),
                        frets: fretboardPositions.map(p => p.fret),
                        notes: fretboardPositions.map(p => p.note),
                        zone: calculerZone(fretboardPositions),
                        span: calculerSpan(fretboardPositions),
                        matchScore: calculerMatchFFT(fretboardPositions, peaks)
                    },
                    
                    confidence: {
                        signalQuality: evaluerQualiteSignal(peaks),
                        stringCount: fretboardPositions.length,
                        reliability: calculerMatchFFT(fretboardPositions, peaks)
                    }
                };
                
                // Afficher la d√©tection structur√©e (D√âSACTIV√â - d√©plac√© apr√®s g√©n√©ration des positions)
                /* console.log(`\nüéµ D√©tection structur√©e:`);
                console.log(`  Accord: ${detectionStructuree.chord.root} ${detectionStructuree.chord.quality}`);
                console.log(`  Notes: ${detectionStructuree.chord.notes.join(', ')}`);
                console.log(`  Position actuelle: Zone ${detectionStructuree.currentPosition.zone}, Span ${detectionStructuree.currentPosition.span} frettes`);
                console.log(`  Match FFT: ${(detectionStructuree.currentPosition.matchScore * 100).toFixed(0)}%`);
                console.log(`  Qualit√© signal: ${detectionStructuree.confidence.signalQuality}`);
                console.log(`  Cordes jou√©es: ${detectionStructuree.confidence.stringCount}/6`);
                console.log(`  Fiabilit√©: ${(detectionStructuree.confidence.reliability * 100).toFixed(0)}%`);
                */
                
                // ============================================================
                // G√âN√âRATION DES POSITIONS MULTIPLES
                // ============================================================
                
                console.log(`\nüé∏ G√©n√©ration des positions possibles...`);
                
                // Fonction pour trouver toutes les positions d'une note sur une corde
                function trouverPositionsNote(note, stringNum) {
                    const positions = [];
                    for (let fret = 0; fret <= 12; fret++) {
                        const fretNote = getStringNote(stringNum, fret);
                        const noteBase = fretNote.replace(/[0-9]/g, ''); // Enlever octave
                        if (noteBase === note) {
                            const freq = noteWithOctaveToFrequency(fretNote);
                            positions.push({ fret, note: fretNote, frequency: freq });
                        }
                    }
                    return positions;
                }
                
                // Fonction pour g√©n√©rer toutes les combinaisons possibles d'un accord
                // Nouvelle logique: Pour chaque position possible de la PREMI√àRE note,
                // placer les autres notes s√©quentiellement sur les cordes suivantes
                function genererPositionsAccord(chordNotes) {
                    const positions = [];
                    
                    if (chordNotes.length === 0) return positions;
                    
                    const premiereNote = chordNotes[0]; // Ex: D
                    
                    // Pour chaque corde (6 ‚Üí 1)
                    for (let startString = 6; startString >= 1; startString--) {
                        // Pour chaque frette o√π on peut placer la premi√®re note (0-11, pas 12)
                        for (let startFret = 0; startFret <= 12; startFret++) {
                            // V√©rifier si cette frette correspond bien √† notre note
                            const fretNote = getStringNote(startString, startFret);
                            const noteBase = fretNote.replace(/[0-9]/g, '');
                            
                            if (noteBase !== premiereNote) {
                                continue; // Pas la bonne note, essayer la frette suivante
                            }
                            
                            // On a trouv√© une position pour la premi√®re note !
                            // Maintenant essayer de placer les autres notes s√©quentiellement
                            const pattern = [null, null, null, null, null, null];
                            const frets = [];
                            
                            // Placer la premi√®re note
                            pattern[6 - startString] = {
                                string: startString,
                                fret: startFret,
                                note: fretNote,
                                frequency: noteWithOctaveToFrequency(fretNote)
                            };
                            frets.push(startFret);
                            
                            // Essayer de placer les notes suivantes
                            let currentString = startString - 1;
                            let allNotesPlaced = true;
                            
                            for (let noteIndex = 1; noteIndex < chordNotes.length; noteIndex++) {
                                const note = chordNotes[noteIndex];
                                
                                if (currentString < 1) {
                                    // Plus de cordes disponibles
                                    // V√©rifier si cette note est une harmonique d'une note d√©j√† jou√©e
                                    const noteFreq = notesFFT[noteIndex].frequency;
                                    let isHarmonicOfPlayed = false;
                                    
                                    for (const playedPos of pattern.filter(p => p !== null)) {
                                        for (let mult = 2; mult <= 6; mult++) {
                                            const harmonicFreq = playedPos.frequency * mult;
                                            const tolerance = harmonicFreq * 0.02; // 2% tolerance
                                            
                                            if (Math.abs(noteFreq - harmonicFreq) < tolerance) {
                                                console.log(`      Note ${noteFreq.toFixed(1)}Hz est harmonique ${mult}√ó de ${playedPos.frequency.toFixed(1)}Hz (jou√©e) ‚Üí OK`);
                                                isHarmonicOfPlayed = true;
                                                break;
                                            }
                                        }
                                        if (isHarmonicOfPlayed) break;
                                    }
                                    
                                    if (isHarmonicOfPlayed) {
                                        // C'est OK, c'est une harmonique d'une note jou√©e
                                        // On continue avec la note suivante (si elle existe)
                                        continue;
                                    } else {
                                        // Ce n'est pas une harmonique, position invalide
                                        console.log(`      Note ${noteFreq.toFixed(1)}Hz ne peut pas √™tre plac√©e et n'est pas une harmonique ‚Üí Position invalide`);
                                        allNotesPlaced = false;
                                        break;
                                    }
                                }
                                
                                // Chercher cette note sur la corde actuelle
                                let notePlaced = false;
                                
                                for (let fret = 0; fret <= 12; fret++) {
                                    const testNote = getStringNote(currentString, fret);
                                    const testNoteBase = testNote.replace(/[0-9]/g, '');
                                    
                                    if (testNoteBase === note) {
                                        // V√©rifier le span
                                        const minFret = Math.min(...frets, fret);
                                        const maxFret = Math.max(...frets, fret);
                                        const span = maxFret - minFret;
                                        
                                        if (span <= 4) {
                                            // Placer cette note
                                            pattern[6 - currentString] = {
                                                string: currentString,
                                                fret: fret,
                                                note: testNote,
                                                frequency: noteWithOctaveToFrequency(testNote)
                                            };
                                            frets.push(fret);
                                            notePlaced = true;
                                            break; // Prendre la premi√®re frette valide
                                        }
                                    }
                                }
                                
                                if (!notePlaced) {
                                    allNotesPlaced = false;
                                    break;
                                }
                                
                                currentString--;
                            }
                            
                            // PHASE DE COMPL√âTION: Essayer d'ajouter des notes sur les cordes restantes
                            // en utilisant les pics FFT apr√®s la derni√®re note plac√©e
                            if (currentString >= 1 && allNotesPlaced) {
                                console.log(`    üîÑ Compl√©tion: Chercher des pics FFT pour les ${currentString} corde(s) restante(s)...`);
                                
                                // Utiliser TOUS les pics classifi√©s (pas juste notesFFT)
                                // On cherche les pics APR√àS la derni√®re note plac√©e
                                const lastPlacedFreq = pattern.filter(p => p !== null)
                                    .map(p => p.frequency)
                                    .sort((a, b) => b - a)[0]; // Plus haute fr√©quence plac√©e
                                
                                // Trouver l'index de cette fr√©quence dans classifiedPeaks
                                let startPeakIndex = 0;
                                for (let i = 0; i < classifiedPeaks.length; i++) {
                                    if (classifiedPeaks[i].frequency > lastPlacedFreq) {
                                        startPeakIndex = i;
                                        break;
                                    }
                                }
                                
                                // Essayer de placer les pics restants
                                for (let peakIndex = startPeakIndex; peakIndex < classifiedPeaks.length && currentString >= 1; peakIndex++) {
                                    const peak = classifiedPeaks[peakIndex];
                                    
                                    // Chercher quelle note correspond √† cette fr√©quence sur la corde actuelle
                                    for (let fret = 0; fret <= 12; fret++) {
                                        const testNote = getStringNote(currentString, fret);
                                        const testFreq = noteWithOctaveToFrequency(testNote);
                                        
                                        // V√©rifier si cette fr√©quence correspond au pic FFT
                                        const tolerance = peak.frequency * 0.03;
                                        if (Math.abs(testFreq - peak.frequency) < tolerance) {
                                            // V√©rifier le span
                                            const newMin = Math.min(...frets, fret);
                                            const newMax = Math.max(...frets, fret);
                                            const newSpan = newMax - newMin;
                                            
                                            if (newSpan <= 4) {
                                                // Placer cette note
                                                pattern[6 - currentString] = {
                                                    string: currentString,
                                                    fret: fret,
                                                    note: testNote,
                                                    frequency: testFreq
                                                };
                                                frets.push(fret);
                                                console.log(`      ‚úÖ Ajout√© ${peak.frequency.toFixed(1)}Hz ‚Üí Corde ${currentString} frette ${fret} (${testNote})`);
                                                currentString--;
                                                break; // Passer √† la corde suivante
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // VALIDATION CRITIQUE: V√©rifier que TOUTES les fondamentales sont plac√©es
                            // Les harmoniques peuvent √™tre absentes (si ce sont des harmoniques de notes jou√©es)
                            // Mais TOUTES les fondamentales DOIVENT √™tre pr√©sentes
                            
                            if (allNotesPlaced || frets.length >= Math.min(chordNotes.length, startString)) {
                                // Identifier les fondamentales dans notesFFT
                                // On utilise classifiedPeaks pour savoir quelles notes sont fondamentales
                                const fondamentalesRequises = [];
                                
                                for (let i = 0; i < notesFFT.length; i++) {
                                    const noteFFT = notesFFT[i];
                                    // Chercher cette note dans classifiedPeaks pour savoir si c'est une fondamentale
                                    const peakClassified = classifiedPeaks.find(p => 
                                        Math.abs(p.frequency - noteFFT.frequency) < 1
                                    );
                                    
                                    if (peakClassified && peakClassified.isFundamental) {
                                        fondamentalesRequises.push(noteFFT.frequency);
                                    }
                                }
                                
                                // V√©rifier que toutes les fondamentales sont dans pattern
                                const toutesLesFondamentalesPresentes = fondamentalesRequises.every(freqRequise => {
                                    return pattern.some(p => 
                                        p !== null && Math.abs(p.frequency - freqRequise) < freqRequise * 0.03
                                    );
                                });
                                
                                if (!toutesLesFondamentalesPresentes) {
                                    const fondamentalesManquantes = fondamentalesRequises.filter(freqRequise => {
                                        return !pattern.some(p => 
                                            p !== null && Math.abs(p.frequency - freqRequise) < freqRequise * 0.03
                                        );
                                    });
                                    console.log(`      ‚ùå Position rejet√©e: manque fondamentale(s) ${fondamentalesManquantes.map(f => f.toFixed(1) + 'Hz').join(', ')}`);
                                } else {
                                    // Toutes les fondamentales sont pr√©sentes, position valide !
                                    const minFret = Math.min(...frets);
                                    const maxFret = Math.max(...frets);
                                    const span = maxFret - minFret;
                                    
                                    positions.push({
                                        pattern: pattern,
                                        frets: frets,
                                        span: span,
                                        startString: startString,
                                        startFret: startFret,
                                        stringCount: pattern.filter(p => p !== null).length
                                    });
                                }
                            }
                        }
                    }
                    
                    return positions;
                }
                
                // G√©n√©rer toutes les positions possibles
                const toutesLesPositions = [];
                
                // IMPORTANT: Utiliser TOUTES les notes FFT d√©tect√©es, pas seulement les notes uniques
                const notesFFT = fretboardPositions.map(p => ({
                    noteBase: p.note.replace(/[0-9]/g, ''),
                    noteComplete: p.note,
                    frequency: p.frequency
                }));
                
                console.log(`  Notes FFT d√©tect√©es (${notesFFT.length}): ${notesFFT.map(n => `${n.noteComplete} (${n.frequency.toFixed(0)}Hz)`).join(', ')}`);
                console.log(`\n  üîç G√©n√©ration de toutes les positions possibles...`);
                
                const positionsGenerees = genererPositionsAccord(notesFFT.map(n => n.noteBase));
                toutesLesPositions.push(...positionsGenerees);
                
                console.log(`  ‚úÖ ${positionsGenerees.length} position(s) g√©n√©r√©e(s)`);
                
                console.log(`\nüéØ Total: ${toutesLesPositions.length} position(s) possible(s) trouv√©e(s)`);
                
                // D√©doublonner les positions identiques (m√™me pattern de frettes)
                const positionsUniques = [];
                const patternsVus = new Set();
                
                toutesLesPositions.forEach(pos => {
                    const patternKey = pos.pattern.map(p => p ? `${p.string}-${p.fret}` : 'x').join('|');
                    if (!patternsVus.has(patternKey)) {
                        patternsVus.add(patternKey);
                        positionsUniques.push(pos);
                    }
                });
                
                console.log(`üìä Apr√®s d√©duplication: ${positionsUniques.length} position(s) unique(s)`);
                
                // Scorer chaque position avec la nouvelle logique
                positionsUniques.forEach((position, index) => {
                    // 1. MATCH FFT (50%) - Toutes les notes jou√©es matchent-elles les pics FFT ?
                    let matchCount = 0;
                    const notesJouees = position.pattern.filter(p => p !== null);
                    
                    notesJouees.forEach(p => {
                        const tolerance = p.frequency * 0.03;
                        const peakMatch = peaks.find(peak => 
                            Math.abs(peak.frequency - p.frequency) < tolerance
                        );
                        if (peakMatch) matchCount++;
                    });
                    
                    const matchFFTScore = notesJouees.length > 0 ? matchCount / notesJouees.length : 0;
                    
                    // 2. CORDES JOU√âES (30%) - Compl√©tude dans la plage de la position
                    // Trouver la corde la plus grave jou√©e (= d√©but de la position)
                    const cordesJouees = position.pattern
                        .map((p, idx) => p !== null ? (6 - idx) : null)
                        .filter(s => s !== null);
                    
                    const firstString = Math.max(...cordesJouees); // Corde la plus grave
                    const lastString = 1; // Toujours jusqu'√† la corde 1
                    const cordesDansPosition = firstString - lastString + 1;
                    const cordesEffectivementJouees = cordesJouees.length;
                    
                    const cordesJoueesScore = cordesEffectivementJouees / cordesDansPosition;
                    
                    // 3. PROBABILIT√â (15%) - Position ouverte > basse > moyenne > haute
                    const minFret = Math.min(...position.frets);
                    let probScore = 1.0;
                    if (minFret <= 3) probScore = 1.0;      // Ouvert
                    else if (minFret <= 7) probScore = 0.8; // Bas
                    else if (minFret <= 10) probScore = 0.6; // Moyen
                    else probScore = 0.4;                    // Haut
                    
                    // 4. COMPACIT√â (5%) - Moins de span = mieux
                    const compacityScore = 1.0 - (position.span / 4);
                    
                    // Score total
                    position.totalScore = 
                        matchFFTScore * 0.50 + 
                        cordesJoueesScore * 0.30 + 
                        probScore * 0.15 + 
                        compacityScore * 0.05;
                    
                    // Stocker les d√©tails pour debug
                    position.scoreDetails = {
                        matchFFT: matchFFTScore,
                        cordesJouees: cordesJoueesScore,
                        probabilite: probScore,
                        compacite: compacityScore,
                        cordesDansPosition: cordesDansPosition,
                        cordesEffectivementJouees: cordesEffectivementJouees
                    };
                });
                
                // Trier par score d√©croissant
                positionsUniques.sort((a, b) => b.totalScore - a.totalScore);
                
                // FILTRER les positions incompl√®tes
                // Compter le nombre de fondamentales d√©tect√©es
                const nombreFondamentales = classifiedPeaks.filter(p => p.isFundamental).length;
                
                let positionsFiltrees = positionsUniques;
                
                if (nombreFondamentales >= 2) {
                    // Exclure les positions avec moins de notes que de fondamentales
                    positionsFiltrees = positionsUniques.filter(pos => {
                        const nombreNotes = pos.pattern.filter(p => p !== null).length;
                        if (nombreNotes < nombreFondamentales) {
                            console.log(`  ‚ùå Position rejet√©e (${nombreNotes} note(s) < ${nombreFondamentales} fondamentales)`);
                            return false;
                        }
                        return true;
                    });
                    console.log(`üìä Filtrage: ${positionsUniques.length} positions ‚Üí ${positionsFiltrees.length} positions compl√®tes (‚â• ${nombreFondamentales} notes)`);
                }
                
                // Prendre les top 6 positions
                const top6 = positionsFiltrees.slice(0, 6);
                
                // Afficher les top positions
                console.log(`\nüèÜ Top ${top6.length} positions:`);
                
                top6.forEach((pos, index) => {
                    const details = pos.scoreDetails;
                    console.log(`\n  Position ${index + 1} (Score: ${(pos.totalScore * 100).toFixed(1)}%, Span: ${pos.span}):`);
                    console.log(`    Match FFT: ${(details.matchFFT * 100).toFixed(0)}% | Cordes: ${details.cordesEffectivementJouees}/${details.cordesDansPosition} (${(details.cordesJouees * 100).toFixed(0)}%) | Prob: ${(details.probabilite * 100).toFixed(0)}% | Compact: ${(details.compacite * 100).toFixed(0)}%`);
                    const stringNames = ['E (6)', 'A (5)', 'D (4)', 'G (3)', 'B (2)', 'E (1)'];
                    pos.pattern.forEach((p, stringIndex) => {
                        if (p !== null) {
                            const fretDisplay = p.fret === 0 ? '√Ä vide' : `Frette ${p.fret}`;
                            console.log(`    ${stringNames[stringIndex]}: ${fretDisplay} ‚Üí ${p.note}`);
                        } else {
                            console.log(`    ${stringNames[stringIndex]}: Non jou√©e`);
                        }
                    });
                });
                
                // ============================================================
                // D√âTECTION STRUCTUR√âE BAS√âE SUR LES POSITIONS G√âN√âR√âES
                // ============================================================
                
                console.log(`\nüìä Analyse de l'accord d√©tect√©...`);
                
                // Extraire toutes les notes uniques de toutes les positions
                const toutesLesNotes = new Set();
                top6.forEach(pos => {
                    pos.pattern.filter(p => p !== null).forEach(p => {
                        const noteBase = p.note.replace(/[0-9]/g, '');
                        toutesLesNotes.add(noteBase);
                    });
                });
                
                const notesDetectees = Array.from(toutesLesNotes).sort();
                const accordDetecte = identifyChord(notesDetectees);
                
                console.log(`\nüéµ D√©tection finale:`);
                console.log(`  Notes d√©tect√©es: ${notesDetectees.join(', ')}`);
                console.log(`  Accord: ${accordDetecte}`);
                console.log(`  ${top6.length} position(s) possible(s) sur le manche`);
                
                // ============================================================
                
                const topNotes = fretboardPositions;
                const usedStrings = new Set();
                
                console.log(`üéº Fretboard detection complete`);
                console.log(`\nüîç Running coherence check...`);
                
                // Check 1: Remove duplicate frequencies (two strings can't play exactly the same Hz)
                const frequencyMap = new Map(); // freq ‚Üí array of positions
                fretboardPositions.forEach(pos => {
                    const freqKey = Math.round(pos.detectedFreq * 10) / 10; // Round to 0.1 Hz
                    if (!frequencyMap.has(freqKey)) {
                        frequencyMap.set(freqKey, []);
                    }
                    frequencyMap.get(freqKey).push(pos);
                });
                
                // If multiple positions share same frequency, keep only the strongest
                frequencyMap.forEach((positions, freq) => {
                    if (positions.length > 1) {
                        console.log(`‚ö†Ô∏è Duplicate frequency ${freq}Hz on strings: ${positions.map(p => p.string).join(', ')}`);
                        
                        // Keep the one with best score (lowest)
                        positions.sort((a, b) => a.score - b.score);
                        const keeper = positions[0];
                        const toRemove = positions.slice(1);
                        
                        toRemove.forEach(pos => {
                            const idx = fretboardPositions.indexOf(pos);
                            if (idx > -1) {
                                console.log(`  ‚ùå Removing string ${pos.string} (weaker match, score: ${pos.score.toFixed(1)})`);
                                fretboardPositions.splice(idx, 1);
                            }
                        });
                        
                        console.log(`  ‚úÖ Keeping string ${keeper.string} (better match, score: ${keeper.score.toFixed(1)})`);
                    }
                });
                
                // Check 2: Validate fret range coherence
                if (fretboardPositions.length > 0) {
                    const frets = fretboardPositions.map(p => p.fret);
                    const minFret = Math.min(...frets);
                    const maxFret = Math.max(...frets);
                    const fretSpan = maxFret - minFret;
                    
                    if (fretSpan > 10) {
                        console.log(`‚ö†Ô∏è Large fret span detected: ${minFret} to ${maxFret} (span: ${fretSpan})`);
                        console.log(`  This might indicate misdetection - review results carefully`);
                    } else {
                        console.log(`‚úÖ Fret span OK: ${minFret} to ${maxFret} (span: ${fretSpan})`);
                    }
                }
                
                console.log(`üîç Coherence check complete: ${fretboardPositions.length} positions validated\n`);
                
                // Sort positions by string number (6 to 1) for display
                fretboardPositions.sort((a, b) => b.string - a.string);
                
                // Display fretboard positions if any were found
                console.log(`üéº Displaying fretboard positions`);
                
                // Afficher les positions multiples trouv√©es
                if (top6.length > 0) {
                    // Extraire toutes les notes uniques pour l'affichage
                    const toutesLesNotesUI = new Set();
                    top6.forEach(pos => {
                        pos.pattern.filter(p => p !== null).forEach(p => {
                            const noteBase = p.note.replace(/[0-9]/g, '');
                            toutesLesNotesUI.add(noteBase);
                        });
                    });
                    const notesDetecteesUI = Array.from(toutesLesNotesUI).sort();
                    const accordDetecteUI = identifyChord(notesDetecteesUI);
                    
                    // AFFICHAGE 1: ACCORD EN GROS (en premier!)
                    const accordEnGrosHTML = `
                        <div style="margin-bottom: 2rem; padding: 2rem; background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-tertiary) 100%); border-radius: 12px; border: 3px solid var(--accent-primary); text-align: center;">
                            <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 1px;">Accord d√©tect√©</div>
                            <div style="font-size: 3rem; font-weight: 900; color: var(--accent-primary); line-height: 1; margin-bottom: 0.5rem;">
                                ${accordDetecteUI}
                            </div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">
                                ${top6.length} position(s) sur le manche
                            </div>
                        </div>
                    `;
                    
                    // Commencer par l'accord en gros
                    debugPeakListContent.innerHTML = accordEnGrosHTML;
                    
                    // AFFICHAGE 2: POSITIONS SUR LE MANCHE
                    let multiPositionsHTML = `
                        <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-size: 0.9rem; color: var(--accent-warning); margin-bottom: 1rem; font-weight: 600;">
                                üé∏ Positions possibles
                            </div>
                    `;
                    
                    const stringNames = ['E (6)', 'A (5)', 'D (4)', 'G (3)', 'B (2)', 'E (1)'];
                    
                    top6.forEach((position, posIndex) => {
                        const scorePercent = Math.round(position.totalScore * 100);
                        const scoreColor = scorePercent >= 80 ? 'var(--accent-success)' : 
                                          scorePercent >= 60 ? 'var(--accent-primary)' : 
                                          'var(--accent-warning)';
                        
                        multiPositionsHTML += `
                            <div style="margin-bottom: 1rem; padding: 0.75rem; background: var(--bg-secondary); border-radius: 6px; border: 2px solid ${posIndex === 0 ? 'var(--accent-success)' : 'var(--border)'};">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem;">
                                    <div style="font-size: 0.8rem; font-weight: 600; color: var(--accent-primary);">
                                        ${posIndex === 0 ? '‚≠ê ' : ''}Position ${posIndex + 1}
                                    </div>
                                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                                        <span style="font-size: 0.75rem; color: var(--text-secondary);">Score:</span>
                                        <span style="font-size: 0.8rem; font-weight: 600; color: ${scoreColor};">${scorePercent}%</span>
                                        <span style="font-size: 0.75rem; color: var(--text-secondary);">Span:</span>
                                        <span style="font-size: 0.8rem; font-weight: 600; color: var(--accent-primary);">${position.span}</span>
                                    </div>
                                </div>
                                <div style="display: grid; gap: 0.25rem;">
                        `;
                        
                        // Afficher chaque corde
                        position.pattern.forEach((p, stringIndex) => {
                            const stringNum = 6 - stringIndex;
                            
                            if (p !== null) {
                                const fretDisplay = p.fret === 0 ? '√Ä vide' : `Frette ${p.fret}`;
                                multiPositionsHTML += `
                                    <div style="display: flex; align-items: center; padding: 0.25rem 0.5rem; background: var(--bg-tertiary); border-radius: 3px;">
                                        <div style="min-width: 45px; font-size: 0.75rem; font-weight: 600; color: var(--accent-primary);">${stringNames[stringIndex]}</div>
                                        <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem;">
                                            <span style="color: var(--accent-success); font-weight: 600; font-size: 0.75rem; min-width: 65px;">${fretDisplay}</span>
                                            <span style="color: var(--text-secondary); font-size: 0.7rem;">‚Üí ${p.note}</span>
                                        </div>
                                    </div>
                                `;
                            } else {
                                multiPositionsHTML += `
                                    <div style="display: flex; align-items: center; padding: 0.25rem 0.5rem; opacity: 0.3;">
                                        <div style="min-width: 45px; font-size: 0.75rem; font-weight: 600; color: var(--text-secondary);">${stringNames[stringIndex]}</div>
                                        <div style="flex: 1; color: var(--text-secondary); font-size: 0.7rem;">Non jou√©e</div>
                                    </div>
                                `;
                            }
                        });
                        
                        multiPositionsHTML += `
                                </div>
                            </div>
                        `;
                    });
                    
                    multiPositionsHTML += `</div>`;
                    
                    // Ajouter les positions apr√®s l'accord
                    debugPeakListContent.innerHTML += multiPositionsHTML;
                    
                    // AFFICHAGE 3: PICS D√âTECT√âS (ajout√© ensuite)
                    const picsHTML = `
                        <div style="margin-top: 2rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border);">
                            <div style="font-size: 0.9rem; color: var(--accent-warning); margin-bottom: 0.75rem; font-weight: 600;">üìä Pics FFT d√©tect√©s</div>
                            <div style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; line-height: 1.6; color: var(--text-primary);">
                                ${storedPeakListHTML}
                            </div>
                        </div>
                    `;
                    
                    debugPeakListContent.innerHTML += picsHTML;
                } else {
                    // Fallback: afficher l'ancienne m√©thode si aucune position trouv√©e
                    if (fretboardPositions.length > 0) {
                        let fretboardHTML = `
                            <div style="margin-top: 1rem; padding: 1rem; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border);">
                                <div style="font-size: 0.8rem; color: var(--accent-warning); margin-bottom: 0.75rem; font-weight: 600;">üéº Position sur le manche (${fretboardPositions.length} cordes d√©tect√©es)</div>
                        `;
                        
                        const stringNames = ['E (6)', 'A (5)', 'D (4)', 'G (3)', 'B (2)', 'E (1)'];
                        
                        for (let s = 6; s >= 1; s--) {
                            const pos = fretboardPositions.find(p => p.string === s);
                            
                            if (pos) {
                                const fretDisplay = pos.fret === 0 ? '√Ä vide' : `Frette ${pos.fret}`;
                                fretboardHTML += `
                                    <div style="display: flex; align-items: center; padding: 0.5rem; margin-bottom: 0.25rem; background: var(--bg-secondary); border-radius: 4px;">
                                        <div style="min-width: 50px; font-weight: 600; color: var(--accent-primary);">${stringNames[6-s]}</div>
                                        <div style="flex: 1; display: flex; align-items: center; gap: 0.5rem;">
                                            <span style="color: var(--accent-success); font-weight: 600; min-width: 80px;">${fretDisplay}</span>
                                            <span style="color: var(--text-secondary); font-size: 0.75rem;">‚Üí ${pos.note}</span>
                                        </div>
                                    </div>
                                `;
                            } else {
                                fretboardHTML += `
                                    <div style="display: flex; align-items: center; padding: 0.5rem; margin-bottom: 0.25rem; background: var(--bg-secondary); border-radius: 4px; opacity: 0.3;">
                                        <div style="min-width: 50px; font-weight: 600; color: var(--text-secondary);">${stringNames[6-s]}</div>
                                        <div style="flex: 1; color: var(--text-secondary); font-size: 0.75rem;">Non jou√©e</div>
                                    </div>
                                `;
                            }
                        }
                        
                        fretboardHTML += `</div>`;
                        debugPeakListContent.innerHTML += fretboardHTML;
                    }
                }
                
                // CHORD RECOGNITION: Extract notes from fretboard positions (more accurate than peaks)
                const detectedNotes = [];
                const seenNotes = new Set();
                
                // Use fretboard positions if available, otherwise fall back to peaks
                if (fretboardPositions.length > 0) {
                    fretboardPositions.forEach(pos => {
                        const noteName = pos.note.replace(/[0-9]/g, ''); // Remove octave number
                        if (!seenNotes.has(noteName)) {
                            detectedNotes.push({note: noteName, frequency: pos.frequency, magnitude: pos.magnitude});
                            seenNotes.add(noteName);
                        }
                    });
                } else {
                    // Fallback to old method (first 10 peaks, filter harmonics)
                    for (let i = 0; i < Math.min(peaks.length, 10); i++) {
                        const peak = peaks[i];
                        const note = frequencyToNote(peak.frequency);
                        
                        if (note && !seenNotes.has(note)) {
                            // Check if this might be a harmonic (skip very high frequencies or obvious harmonics)
                            let isLikelyHarmonic = false;
                            
                            // Check if this peak is a harmonic of a lower peak
                            for (let j = 0; j < i; j++) {
                                const lowerPeak = peaks[j];
                                const ratio = peak.frequency / lowerPeak.frequency;
                                // If it's close to 2x, 3x, 4x etc, it's likely a harmonic
                                for (let mult = 2; mult <= 6; mult++) {
                                    if (Math.abs(ratio - mult) < 0.05) {
                                        isLikelyHarmonic = true;
                                        break;
                                    }
                                }
                                if (isLikelyHarmonic) break;
                            }
                            
                            if (!isLikelyHarmonic || detectedNotes.length < 3) {
                                detectedNotes.push({note: note, frequency: peak.frequency, magnitude: peak.magnitude});
                                seenNotes.add(note);
                            }
                        }
                    }
                }
                
                // Try to identify the chord
                if (detectedNotes.length >= 2) {
                    const noteNames = detectedNotes.map(n => n.note);
                    const chordName = identifyChord(noteNames);
                    
                    console.log(`üé∏ Chord recognition: Notes detected = ${noteNames.join(', ')} ‚Üí Chord = ${chordName}`);
                    
                    // L'affichage chord recognition est maintenant fait EN GROS en haut (avant les positions)
                    // Plus besoin d'afficher ici
                }
            }
        }
        
        // Debug reset button
        if (debugResetBtn) {
            debugResetBtn.addEventListener('click', () => {
                console.log('üî¨ Reset button clicked');
                resetDebugMode();
            });
        } else {
            console.error('‚ùå debugResetBtn not found!');
        }
        
        // Zoom controls
        if (zoomInBtn) {
            zoomInBtn.addEventListener('click', () => {
                waveformZoom = Math.min(waveformZoom * 2, 64);
                zoomLevel.textContent = `${waveformZoom}√ó`;
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                    updateFFTFromZoom();
                }
            });
        }
        
        if (zoomOutBtn) {
            zoomOutBtn.addEventListener('click', () => {
                waveformZoom = Math.max(waveformZoom / 2, 1);
                waveformOffset = 0; // Reset offset when zooming out
                zoomLevel.textContent = `${waveformZoom}√ó`;
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                    updateFFTFromZoom();
                }
            });
        }
        
        if (useZoomedFFT) {
            useZoomedFFT.addEventListener('change', () => {
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    updateFFTFromZoom();
                }
            });
        }
        
        // Function to update FFT based on zoom
        async function updateFFTFromZoom() {
            if (!useZoomedFFT || !useZoomedFFT.checked || !debugFrozenFFT || !debugFrozenFFT.timeDomain) {
                // Use original full FFT
                if (debugFrozenFFT) {
                    drawDebugSpectrum({
                        dataArray: debugFrozenFFT.dataArray,
                        bufferLength: debugFrozenFFT.bufferLength,
                        sampleRate: debugFrozenFFT.sampleRate,
                        nyquist: debugFrozenFFT.nyquist
                    });
                    analyzeDebugFFT({
                        dataArray: debugFrozenFFT.dataArray,
                        bufferLength: debugFrozenFFT.bufferLength,
                        sampleRate: debugFrozenFFT.sampleRate,
                        nyquist: debugFrozenFFT.nyquist
                    });
                }
                return;
            }
            
            // Calculate visible range
            const timeDomainData = debugFrozenFFT.timeDomain;
            const bufferLength = timeDomainData.length;
            const width = debugWaveformCanvas.width;
            const samplesPerPixel = bufferLength / width / waveformZoom;
            const centerSample = bufferLength / 2 + waveformOffset;
            const startSample = Math.max(0, Math.floor(centerSample - (width / 2) * samplesPerPixel));
            const endSample = Math.min(bufferLength, Math.ceil(centerSample + (width / 2) * samplesPerPixel));
            
            console.log(`üî¨ Computing FFT on visible window: ${startSample}-${endSample} (${endSample - startSample} samples, ${((endSample - startSample) / 44100 * 1000).toFixed(1)}ms)`);
            
            // Compute FFT on visible window
            try {
                const windowFFT = await computeFFTFromWindow(timeDomainData, startSample, endSample);
                console.log(`üî¨ Window FFT computed: ${windowFFT.fftSize} FFT size, resolution ${(windowFFT.sampleRate / windowFFT.fftSize).toFixed(2)} Hz/bin`);
                
                // Draw and analyze with windowed FFT
                drawDebugSpectrum(windowFFT);
                analyzeDebugFFT(windowFFT);
            } catch (error) {
                console.error('‚ùå Error computing windowed FFT:', error);
            }
        }
        
        if (zoomResetBtn) {
            zoomResetBtn.addEventListener('click', () => {
                waveformZoom = 1;
                waveformZoomY = 1;
                waveformOffset = 0;
                waveformOffsetY = 0;
                zoomLevel.textContent = '1√ó';
                zoomYLevel.textContent = '1√ó';
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                }
            });
        }
        
        // Zoom Y controls
        if (zoomYInBtn) {
            zoomYInBtn.addEventListener('click', () => {
                waveformZoomY = Math.min(waveformZoomY * 2, 32);
                zoomYLevel.textContent = `${waveformZoomY}√ó`;
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                }
            });
        }
        
        if (zoomYOutBtn) {
            zoomYOutBtn.addEventListener('click', () => {
                waveformZoomY = Math.max(waveformZoomY / 2, 1);
                waveformOffsetY = 0; // Reset Y offset when zooming out
                zoomYLevel.textContent = `${waveformZoomY}√ó`;
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                }
            });
        }
        
        // Canvas drag for panning
        if (debugWaveformCanvas) {
            debugWaveformCanvas.addEventListener('mousedown', (e) => {
                waveformDragging = true;
                waveformDragStartX = e.clientX;
                waveformDragStartY = e.clientY;
                waveformDragStartOffset = waveformOffset;
                waveformDragStartOffsetY = waveformOffsetY;
            });
            
            debugWaveformCanvas.addEventListener('mousemove', (e) => {
                if (waveformDragging && debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    // Horizontal panning (time)
                    const deltaX = e.clientX - waveformDragStartX;
                    const bufferLength = debugFrozenFFT.timeDomain.length;
                    const canvasWidth = debugWaveformCanvas.width;
                    const samplesPerPixel = bufferLength / canvasWidth / waveformZoom;
                    waveformOffset = waveformDragStartOffset - deltaX * samplesPerPixel;
                    
                    // Clamp offset
                    const maxOffset = bufferLength / 2 - canvasWidth / 2 * samplesPerPixel;
                    waveformOffset = Math.max(-maxOffset, Math.min(maxOffset, waveformOffset));
                    
                    // Vertical panning (amplitude)
                    const deltaY = e.clientY - waveformDragStartY;
                    const canvasHeight = debugWaveformCanvas.height;
                    const amplitudeRange = 2.0; // -1 to +1
                    const amplitudePerPixel = amplitudeRange / canvasHeight / waveformZoomY;
                    waveformOffsetY = waveformDragStartOffsetY + deltaY * amplitudePerPixel;
                    
                    // Clamp Y offset
                    const maxOffsetY = 0.5 / waveformZoomY;
                    waveformOffsetY = Math.max(-maxOffsetY, Math.min(maxOffsetY, waveformOffsetY));
                    
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                }
            });
            
            debugWaveformCanvas.addEventListener('mouseup', () => {
                waveformDragging = false;
                // Update FFT after dragging
                updateFFTFromZoom();
            });
            
            debugWaveformCanvas.addEventListener('mouseleave', () => {
                if (waveformDragging) {
                    waveformDragging = false;
                    updateFFTFromZoom();
                }
            });
            
            // Mouse wheel for zoom
            debugWaveformCanvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (debugFrozenFFT && debugFrozenFFT.timeDomain) {
                    if (e.shiftKey) {
                        // Shift + Wheel = Zoom Y
                        if (e.deltaY < 0) {
                            waveformZoomY = Math.min(waveformZoomY * 1.5, 32);
                        } else {
                            waveformZoomY = Math.max(waveformZoomY / 1.5, 1);
                            if (waveformZoomY === 1) waveformOffsetY = 0;
                        }
                        zoomYLevel.textContent = `${waveformZoomY.toFixed(1)}√ó`;
                    } else {
                        // Normal Wheel = Zoom X
                        if (e.deltaY < 0) {
                            waveformZoom = Math.min(waveformZoom * 1.5, 64);
                        } else {
                            waveformZoom = Math.max(waveformZoom / 1.5, 1);
                            if (waveformZoom === 1) waveformOffset = 0;
                        }
                        zoomLevel.textContent = `${waveformZoom.toFixed(1)}√ó`;
                    }
                    drawDebugWaveform(debugFrozenFFT.timeDomain);
                }
            });
        }

        // Initialize
        initializeEnabledStrings();
        generateExercise();
        
        // Show fretboard and instrument selection by default (since checkbox is checked)
        if (showFretboardCheckbox.checked) {
            instrumentSelection.style.display = 'block';
            fretCountSelection.style.display = 'block';
            if (currentExercise && currentExercise.type === 'chord') {
                drawChordFretboard(currentExercise.chord);
            }
        }
        
        // Display version number
        document.getElementById('appVersion').textContent = APP_VERSION;
        
        // Speed mode start button
        speedModeStartBtn.onclick = startSpeedMode;
        
        // Don't auto-start microphone since settings are open at startup
        // Microphone will be started when user closes settings and begins training
        
        // Register Service Worker for PWA (only on proper domains)
        if ('serviceWorker' in navigator && isValidDomain) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker enregistr√©:', registration);
                    })
                    .catch(error => {
                        console.log('Erreur Service Worker:', error);
                    });
            });
        }
    </script>
</body>
</html>